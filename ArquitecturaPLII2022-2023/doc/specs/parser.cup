package compiler.syntax;

// Declaracion de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;

import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaracion del codigo de usuario

action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();
	
	// Lista para almacenar las cadenas de caracteres
	List<QuadrupleIF> listaCadenas = new ArrayList<>();

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// Declaracion de terminales


terminal Token PLUS;
terminal Token AUTO_INCREMENTO;
terminal Token MULT;
terminal Token AND_LOGICA;
terminal Token OPEN_BRACKET;
terminal Token CLOSE_BRACKET;
terminal Token OPEN_PARENTHESIS;
terminal Token CLOSE_PARENTHESIS;
terminal Token OPEN_KEY;
terminal Token CLOSE_KEY;
terminal Token SEMI_COLON;
terminal Token COLON;
terminal Token TWO_POINTS;
terminal Token NEGACION;
terminal Token EQUAL;
terminal Token ASSIGN_SUMA;
terminal Token ASSIGN;
terminal Token LOWER_THAN;
terminal Token CASO;
terminal Token CONSTANTE;
terminal Token CORTE;
terminal Token ENTERO;
terminal Token ESCRIBE;
terminal Token ESCRIBE_ENT;
terminal Token ALTENATIVAS;
terminal Token MIENTRAS;
terminal Token PORDEFECTO;
terminal Token principal;
terminal Token DEVUELVE;
terminal Token SI;
terminal Token SINO;
terminal Token TIPO;
terminal Token VACIO;
terminal Token IDENTIFICADOR;
terminal Token NUMERO;
terminal Token STRING;


// Declaracion de no terminales

non terminal Program                 program;
non terminal Axiom	                 axiom;
non terminal Axiom2                  axiom2;
non terminal FuncionPrincipal        funcionPrincipal;
non terminal Epsilon   			     epsilon;
non terminal SeccionFunciones        seccionFunciones;
non terminal Funcion 			     funcion;
non terminal SeccionParametros	     seccionParametros;
non terminal DeclaracionParametros   declaracionParametros;
non terminal Parametro			     parametro;
non terminal SeccionConstantes	     seccionConstantes;
non terminal DeclaracionConstante    declaracionConstante;
non terminal SeccionTipos		     seccionTipos;
non terminal DeclaracionTipo	     declaracionTipo;
non terminal 			             tamTipo;
non terminal SeccionVariables	     seccionVariables;
non terminal DeclaracionVariable     declaracionVariable;
non terminal ListadoIDs			     listadoIDs;
non terminal Id			             id;
non terminal Expresion               expresion;
non terminal AccesoVector 		     accesoVector;
non terminal LlamadaFuncion		     llamadaFuncion;
non terminal Bloque			         bloque;
non terminal ListadoSentencias       listadoSentencias;
non terminal Sentencia			     sentencia;
non terminal SentenciaIncremento     sentenciaIncremento;
non terminal SentenciaAsignacion     sentenciaAsignacion;
non terminal Ref			         ref;
non terminal SentenciaAsignacionSuma sentenciaAsignacionSuma;
non terminal SentenciaSi			 sentenciaSi;
non terminal SentenciaAlternativas   sentenciaAlternativas;
non terminal CasosAlternativa		 casosAlternativa;
non terminal CasoAlt			     casoAlt; 
non terminal PorDefecto			     porDefecto;
non terminal SentenciaMientras		 sentenciaMientras;
non terminal SentenciaLlamadaFuncion sentenciaLlamadaFuncion;
non terminal Parametros			     parametros;
non terminal SentenciaSalida         sentenciaSalida;
non terminal OpcionesEscribe         opcionesEscribe;
non terminal OpcionesEscribeEnt		 opcionesEscribeEnt;
non terminal SentenciaDevuelve		 sentenciaDevuelve;

non terminal CuerpoFuncion cuerpoFuncion;
non terminal CuerpoBloque cuerpoBloque;

// Declaracion de relaciones de precedencia
precedence left     AND_LOGICA;
precedence left		EQUAL;
precedence left		LOWER_THAN;
precedence left		PLUS;
precedence left		MULT;
precedence left		AUTO_INCREMENTO, NEGACION;
precedence right	OPEN_BRACKET, CLOSE_BRACKET;
precedence left 	OPEN_KEY, CLOSE_KEY;
precedence nonassoc SINO;
precedence nonassoc SI;
            

// Declaracion de reglas de produccion


start with program;

program ::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   :}
  axiom:ax
  {:   	
  		
  		String cuadruplas = "";
		List<QuadrupleIF> ic = ax.getIntermediateCode();

		for(QuadrupleIF q : ic){
			cuadruplas += q.toString() + "\n";
		}
		//descomentar para mostrar las cuadruplas que llegan al axioma
		//semanticErrorManager.semanticDebug ("***** CUADRUPLAS *****: \n" + cuadruplas);
		
  		// No modificar esta estructura, aunque se pueden a√±adir m√°s acciones sem√°nticas
  		
  		List intermediateCode = ax.getIntermediateCode ();
  		finalCodeFactory.setEnvironment(CompilerContext.getExecutionEnvironment());
  		finalCodeFactory.create (intermediateCode);

  		// En caso de no comentarse las dos sentencias anteriores se puede generar una excepcion
  		// en las llamadas a cupTest si el compilador no est√° completo. Esto es debido a que 
  		// a√∫n no se tendr√° implementada la generaci√≥n de c√≥digo intermedio ni final.
  		// Para la entrega final deber√°n descomentarse y usarse.
  		
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
  		
   :};

// Hay 2 producciones axioma para solventar las ambiguedades:
// axiom crea el ambito global, llama a axiom2 y asigna las direcciones estaticas
// axiom2 genera las secciones principales del programa

axiom ::= {:
				// Creamos ambito global 							
				ScopeIF scope = scopeManager.openScope("global");
												
				// Obtener tablas de tipos e introducir tipos primitivos
				TypeTableIF typeTable = scope.getTypeTable();					
				TypeSimpleEntero tipoEntero = new TypeSimpleEntero(scope, "ENTERO");
				typeTable.addType("ENTERO", tipoEntero);
				TypeSimpleVacio tipoVacio = new TypeSimpleVacio(scope, "VACIO");
				typeTable.addType("VACIO", tipoVacio);							
		  	  :}
			
			  axiom2:ax2 {:
			  	 
			  	Axiom axiom = new Axiom();			  	
			  	
			  	// Asignacion de posiciones de memoria para variables y temporales
			  	
			  	int dirEstatica = 65535;
			  	
			  	for(ScopeIF s : scopeManager.getAllScopes()){  				  					  							  		
			  		for(SymbolIF sim : s.getSymbolTable().getSymbols()){			  			
			  			if(sim instanceof SymbolVariable){
			  				// guarda la direccion en SymbolVariable.java y actualiza dir
			  				((SymbolVariable)sim).setAddress(dirEstatica);
			  				dirEstatica -= sim.getType().getSize();			  				
			  			}
			  		}			  		
			  		for(TemporalIF temp : s.getTemporalTable().getTemporals()){
			  			if(temp instanceof Temporal){
			  				// guarda la direccion en Temporal.java y actualiza dir
			  				((Temporal)temp).setAddress(dirEstatica);
			  				dirEstatica -= ((Temporal)temp).getSize();
			  			}
			  		}
			  	}
			  	
			  	/*----- CÛdigo intermedio -----*/
			  	
			  	ScopeIF scope = scopeManager.getCurrentScope(); 
			  	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);				  	 
			  	cb.addQuadruples(ax2.getIntermediateCode());
			  	
			  	//finalizacion del programa
			  	cb.addQuadruple("HALT");
			  	//anadir las cadenas al final del programa			  	
			  	for(QuadrupleIF q : listaCadenas){
			  		cb.addQuadruple(q);
			  	}			  				  	
			  	
			  	axiom.setIntermediateCode(cb.create());
			  	RESULT = axiom;	
			  				
				scopeManager.closeScope();	
						
		   :};



axiom2 ::= seccionConstantes:sC seccionTipos:sT seccionVariables:sV seccionFunciones:sF{:
		     
		     Axiom2 axiom2 = new Axiom2(sC,sT,sV,sF);
		     
		     /*----- CÛdigo intermedio -----*/
						   		
		   	 ScopeIF scope = scopeManager.getCurrentScope();
			 IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
			 
			 cb.addQuadruples(sV.getIntermediateCode());
			 cb.addQuadruples(sF.getIntermediateCode());		     
		     axiom2.setIntermediateCode(cb.create());
		     RESULT = axiom2;
		 :}
	     | seccionConstantes:sC seccionTipos:sT seccionFunciones:sF{:
	       	 
	       	 Axiom2 axiom2 = new Axiom2(sC,sT,sF);
	       	 
	       	 /*----- CÛdigo intermedio -----*/
						   		
		   	 ScopeIF scope = scopeManager.getCurrentScope();
			 IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
			 
			 cb.addQuadruples(sF.getIntermediateCode());	       	 
	       	 axiom2.setIntermediateCode(cb.create());
		     RESULT = axiom2;
		 :};
		 
		 
		 
/* CONSTANTES  *******************************************************************************************/

seccionConstantes ::= declaracionConstante:dec seccionConstantes:sC{:

						  if(sC == null){							    			     
						  	sC = new SeccionConstantes();		
						  }
						  sC.add(dec);		  

						  RESULT = sC;
                    :}
                    | epsilon;
epsilon ::= ;

declaracionConstante ::= CONSTANTE IDENTIFICADOR:id NUMERO:value SEMI_COLON{:  	      		 	
							
							ScopeIF scope = scopeManager.getCurrentScope();
							DeclaracionConstante dC = new DeclaracionConstante();
							
							/*----- An·lisis sem·ntico -----*/
							
							SymbolTableIF tablaSimbolos = scope.getSymbolTable();
							TypeTableIF tablaTipos = scope.getTypeTable();
														
							// Comprobar que la constante no este ya declarada
							if(tablaSimbolos.containsSymbol(id.getLexema())){
								semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": constante '" + id.getLexema() + "' ya declarada");								
							}	
																				
							TypeIF tipo = scopeManager.searchType("ENTERO");  
							SymbolConstant symbolConstant = new SymbolConstant(scope, id.getLexema(), tipo);
							symbolConstant.setValue(Integer.parseInt(value.getLexema())); 
							tablaSimbolos.addSymbol(symbolConstant);	
							dC.setSymbolConstant(symbolConstant);													
									
							RESULT = dC;							
					   :};



/* TIPOS  *******************************************************************************************/

seccionTipos ::= declaracionTipo:decTip seccionTipos:secTip{:	
					if(secTip == null){			
						secTip = new SeccionTipos();
					}  
					secTip.add(decTip);       
					RESULT = secTip;
               :} 
               | epsilon;

declaracionTipo ::= TIPO ENTERO IDENTIFICADOR:id OPEN_BRACKET tamTipo:tt CLOSE_BRACKET SEMI_COLON {:		      		 		
							
						
						ScopeIF scope = scopeManager.getCurrentScope();
						TypeTableIF tablaTipos = scope.getTypeTable();	
												
						// Comprobar que el tipo no este ya declarado y el tamano sea mayor que 0
						int size = (int)tt;
						if(scopeManager.containsType(id.getLexema())){
							semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": Tipo '" +id.getLexema()+"' ya declarado");																				
						}								
						if( size < 1){
							semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": El tamano de un vector debe ser mayor que 0");
						}	
																														
						// Introducir tipo en tabla de tipos								
						TypeArray tipoVector = new TypeArray(scope, id.getLexema(), size);
						tablaTipos.addType(id.getLexema(), tipoVector);
							
						RESULT = new DeclaracionTipo(tipoVector);							
					:}; 

tamTipo ::= NUMERO:num {: 
				RESULT = Integer.parseInt(num.getLexema()); 
		  :}
          | IDENTIFICADOR:id {:     
               
                // El id debe existir y debe ser una constante           
                
				SymbolTableIF tablaSimbolos = scopeManager.getCurrentScope().getSymbolTable();
				if(!scopeManager.containsSymbol(id.getLexema())){
					semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": No existe la constante '" + id.getLexema() + "'");
				}
				SymbolIF symbol = scopeManager.searchSymbol(id.getLexema());
				
				if( !(symbol instanceof SymbolConstant) ){
					semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": El simbolo '" + id.getLexema() + "' no es una constante");
				}
				
				RESULT = ((SymbolConstant)symbol).getValue();					
          :};
          
          
          
/* VARIABLES  *******************************************************************************************/

seccionVariables ::= seccionVariables:sV declaracionVariable:dec{:

						sV.add(dec);
						
						/*----- CÛdigo intermedio -----*/
						
						ScopeIF scope = scopeManager.getCurrentScope();
				   		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				   		
				   		cb.addQuadruples(sV.getIntermediateCode());  
				   		cb.addQuadruples(dec.getIntermediateCode());       
				   		
				   		sV.setIntermediateCode(cb.create());
						RESULT = sV;
				   :}
	               | declaracionVariable:dec{:
	               		
	               		SeccionVariables sV = new SeccionVariables();
	               		sV.add(dec);
	               		
	               		/*----- CÛdigo intermedio -----*/
	               		
	               		ScopeIF scope = scopeManager.getCurrentScope();
				   		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	               		
	               		cb.addQuadruples(dec.getIntermediateCode());
	               
	               		sV.setIntermediateCode(cb.create());
						RESULT = sV;
				   :};
				   
		
declaracionVariable ::= ENTERO listadoIDs:lIDs SEMI_COLON:sc{:  							
														
							ScopeIF scope = scopeManager.getCurrentScope();
							SymbolTableIF tablaSimbolos = scope.getSymbolTable();
							IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);														
							
							// Anadir cada identificador a tabla de simbolos							
							for(Id id : lIDs.getListaIds()){								
								
								DeclaracionVariable dV = new DeclaracionVariable();
								
								/*----- An·lisis sem·ntico -----*/
												
								if(tablaSimbolos.containsSymbol(id.getName())){
									semanticErrorManager.semanticFatalError("Error en linea " + sc.getLine() + ": variable '" + id.getName() + "' ya declarada");								
								}	
																	
								TypeIF tipo = scopeManager.searchType("ENTERO");  
								SymbolVariable symbolVariable = new SymbolVariable(scope, id.getName(), tipo);
								symbolVariable.setValue(id.getValue()); 
								tablaSimbolos.addSymbol(symbolVariable);
								dV.setSymbolVariable(symbolVariable);								
								
								/*----- CÛdigo intermedio -----*/								
								
								Variable var = new Variable(symbolVariable);								
								cb.addQuadruple("VAR",var,symbolVariable.getValue());								
								
								dV.setIntermediateCode(cb.create());
								RESULT = dV;								
							}					
					   :}
					   
 	                  | IDENTIFICADOR:iden listadoIDs:lIDs SEMI_COLON:sc{:
							
							ScopeIF scope = scopeManager.getCurrentScope();
							SymbolTableIF tablaSimbolos = scope.getSymbolTable();
							IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);				
							
							// Anadir cada identificador a tabla de simbolos
							for(Id id : lIDs.getListaIds()){
								
								DeclaracionVariable dV = new DeclaracionVariable();
								
								/*----- An·lisis sem·ntico -----*/
														
								if(tablaSimbolos.containsSymbol(id.getName())){
									semanticErrorManager.semanticFatalError("Error en linea " + sc.getLine() + ": variable '" + id.getName() + "' ya declarada");								
								}																	
								if(!scopeManager.containsType(iden.getLexema())){
									semanticErrorManager.semanticFatalError("Error en linea " + sc.getLine() + ": tipo '" + iden.getLexema() + "' no declarado");
								}	
																
								TypeIF tipo = scopeManager.searchType(iden.getLexema());  
								SymbolVariable symbolVariable = new SymbolVariable(scope, id.getName(), tipo);							
								tablaSimbolos.addSymbol(symbolVariable);
								dV.setSymbolVariable(symbolVariable);
								
								/*----- CÛdigo intermedio -----*/								
								
								Variable var = new Variable(symbolVariable);								
								cb.addQuadruple("VAR",var,symbolVariable.getValue());								
							
								dV.setIntermediateCode(cb.create());
								RESULT = dV;	
							}					
					   :};

listadoIDs ::= id:id COLON listadoIDs:listaId {:			   		
			   		listaId.add(id);
			   		RESULT = listaId;
			 :}			 			 
			 | id:id{:			 
			   		ListadoIDs listaId = new ListadoIDs();
			   		listaId.add(id);
			   		RESULT = listaId;			 
			 :} ;

id ::= IDENTIFICADOR:id{:	      		   
            String name = id.getLexema();			
			RESULT = new Id(name, 0);						
     :}     
	 | IDENTIFICADOR:id ASSIGN NUMERO:num{:	   		
   			String name = id.getLexema();
			int value = Integer.parseInt(num.getLexema());			
			RESULT = new Id(name, value);					
     :};



/* FUNCIONES  *******************************************************************************************/

// Se han modificado las producciones de la funcion principal y las funciones para que
// ambas uilicen el no terminal "cuerpoFuncion" y asi evitar conflictos
      
seccionFunciones ::= funcion:fun seccionFunciones:sF{:

                        sF.addFuncion(fun);
                        RESULT = sF;	
                        					
                   :}
                   | funcionPrincipal:funP{:
                   		
                   		SeccionFunciones sF = new SeccionFunciones(funP); 
                   		
                   		/*----- CÛdigo intermedio -----*/
						
	                    ScopeIF scope = scopeManager.getCurrentScope();
				   		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);   
				   		
				   		cb.addQuadruples(funP.getIntermediateCode());
                   		
                   		sF.setIntermediateCode(cb.create());
                   		RESULT = sF;              
                   :};

funcionPrincipal ::= VACIO principal OPEN_KEY CLOSE_KEY OPEN_PARENTHESIS{:	

                     	//Declarar funcion principal en tabla de tipos y simbolos global                     	
                        ScopeIF globalScope = scopeManager.getCurrentScope();
                     	SymbolTableIF globalTablaSimbolos = globalScope.getSymbolTable();
						TypeTableIF globalTablaTipos = globalScope.getTypeTable();	
                     	
                     	TypeIF tipo = scopeManager.searchType("VACIO");  
						SymbolFunction symbolFunction = new SymbolFunction(globalScope, "principal", tipo);
						globalTablaSimbolos.addSymbol(symbolFunction);	
						TypeFunction typeFunction = new TypeFunction(globalScope, "principal");
						globalTablaTipos.addType("principal", typeFunction);
						
						// Crear ambito de la funcion principal y obtener sus tablas						
						ScopeIF scope = scopeManager.openScope("Funcion principal");							
						SymbolTableIF tablaSimbolos = scope.getSymbolTable();                      
						TypeTableIF tablaTipos = scope.getTypeTable();																								
				  	 :} 
				  	 
				  	 cuerpoFuncion:cFun CLOSE_PARENTHESIS {:		
				  	 	
				  	 	/*----- An·lisis sem·ntico -----*/
				  	 	
				  	 	if(cFun.getListadoSentencias().getDevuelve()){
							semanticErrorManager.semanticFatalError("Error: La funcion principal no debe devolver una expresiÛn");
						}	
						
						TypeIF tipo = scopeManager.searchType("VACIO");
						FuncionPrincipal funP = new FuncionPrincipal(tipo,"principal",cFun);
						
						/*----- CÛdigo intermedio -----*/
				
						ScopeIF scope = scopeManager.getCurrentScope();
						IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				
						cb.addQuadruples(cFun.getIntermediateCode());
						
						funP.setIntermediateCode(cb.create());
						RESULT = funP;
																
						scopeManager.closeScope();	
		
					 :};

funcion ::= ENTERO IDENTIFICADOR:id OPEN_KEY seccionParametros:sP CLOSE_KEY OPEN_PARENTHESIS
            {:
            	
            	ScopeIF globalScope = scopeManager.getCurrentScope();
                SymbolTableIF globalTablaSimbolos = globalScope.getSymbolTable();
				TypeTableIF globalTablaTipos = globalScope.getTypeTable();
				
            	// Comprobar que la funcion no ha sido ya declarada
            	if(globalTablaSimbolos.containsSymbol(id.getLexema())){
					semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": la funcion '" + id.getLexema() + "' ya ha sido declarada");								
				}
				
            	// Declarar funcion en tabla de tipos y tabla de simbolos global                   	
                TypeIF type = scopeManager.searchType("ENTERO");  
				SymbolFunction symbolFunction = new SymbolFunction(globalScope, id.getLexema(), type);
				globalTablaSimbolos.addSymbol(symbolFunction);	
				TypeFunction typeFunction = new TypeFunction(globalScope, id.getLexema());
				globalTablaTipos.addType(id.getLexema(), typeFunction);
            	
				// Crear ambito de la funcion y obtener sus tablas								
				ScopeIF scope = scopeManager.openScope("Funcion " + id.getLexema());					
				SymbolTableIF tablaSimbolos = scope.getSymbolTable();                        
				TypeTableIF tablaTipos = scope.getTypeTable();							
				
				//Declaracion de parametros en el ambito de la funcion								
				if(sP != null){							
					symbolFunction.setParametros(sP.getDeclaracionParametros().getListaParam());									
					for(Parametro param : sP.getDeclaracionParametros().getListaParam()){					 
						SymbolParameter symbolParameter = new SymbolParameter(scope, param.getName(), param.getType());							
						tablaSimbolos.addSymbol(symbolParameter);
					}
				}													
			:} 
			 
			cuerpoFuncion:cFun CLOSE_PARENTHESIS {:	
				
				/*----- An·lisis sem·ntico -----*/
				
				if(!cFun.getListadoSentencias().getDevuelve()){
					semanticErrorManager.semanticFatalError("Error: La funcion '" +id.getLexema()+"' debe devolver una expresiÛn de tipo entero");
				}
				
				TypeIF tipo = scopeManager.searchType("ENTERO");
				Funcion fun = new Funcion(tipo,id.getLexema(),sP,cFun);
				
				RESULT = fun;								
				scopeManager.closeScope();	
		
			:}
			 
	      | VACIO IDENTIFICADOR:id OPEN_KEY seccionParametros:sP CLOSE_KEY OPEN_PARENTHESIS {:
	      		
	      		ScopeIF globalScope = scopeManager.getCurrentScope();
                SymbolTableIF globalTablaSimbolos = globalScope.getSymbolTable();
				TypeTableIF globalTablaTipos = globalScope.getTypeTable();
				
            	// Comprobar que la funcion no ha sido ya declarada
            	if(globalTablaSimbolos.containsSymbol(id.getLexema())){
					semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": la funcion '" + id.getLexema() + "' ya ha sido declarada");								
				}
				
	        	//Declarar funcion en tabla de tipos y tabla de simbolos global  	        	               	
                TypeIF type = scopeManager.searchType("VACIO");  
				SymbolFunction symbolFunction = new SymbolFunction(globalScope, id.getLexema(), type);
				globalTablaSimbolos.addSymbol(symbolFunction);	
				TypeFunction typeFunction = new TypeFunction(globalScope, id.getLexema());
				globalTablaTipos.addType(id.getLexema(), typeFunction);
				
				// Crea ambito de la funcion y obtener sus tablas									
				ScopeIF scope = scopeManager.openScope("Funcion " + id.getLexema());					
				SymbolTableIF tablaSimbolos = scope.getSymbolTable();                             
				TypeTableIF tablaTipos = scope.getTypeTable();
								
				//Declaracion de parametros en el ambito de la funcion					
				if(sP != null){								
				    symbolFunction.setParametros(sP.getDeclaracionParametros().getListaParam());								
					for(Parametro param : sP.getDeclaracionParametros().getListaParam()){							
						SymbolParameter symbolParameter = new SymbolParameter(scope, param.getName(), param.getType());							
						tablaSimbolos.addSymbol(symbolParameter);
					}				
				}											
			:} 
			 
			cuerpoFuncion:cFun CLOSE_PARENTHESIS {:			
				
				/*----- An·lisis sem·ntico -----*/
				
				if(cFun.getListadoSentencias().getDevuelve()){
					semanticErrorManager.semanticFatalError("Error: La funcion '" +id.getLexema()+"' no debe devolver una expresiÛn");
				}
				
				TypeIF tipo = scopeManager.searchType("VACIO");
				Funcion fun = new Funcion(tipo,id.getLexema(),sP,cFun);
				
				RESULT = fun;			
				scopeManager.closeScope();		
		
			:};
			
			
cuerpoFuncion ::= seccionTipos:sT listadoSentencias:lS{:
     
					CuerpoFuncion cP = new CuerpoFuncion(sT,lS);
					
					/*----- CÛdigo intermedio -----*/
						   		
					ScopeIF scope = scopeManager.getCurrentScope();
					IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
					
					cb.addQuadruples(lS.getIntermediateCode());
					
					cP.setIntermediateCode(cb.create());
					RESULT = cP;
                :}
                | seccionTipos:sT seccionVariables:sV listadoSentencias:lS{:
					
                	CuerpoFuncion cP = new CuerpoFuncion(sT,sV,lS);
                	
                	/*----- CÛdigo intermedio -----*/
						   		
					ScopeIF scope = scopeManager.getCurrentScope();
					IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
					
					cb.addQuadruples(sV.getIntermediateCode());
					cb.addQuadruples(lS.getIntermediateCode());
					
					cP.setIntermediateCode(cb.create());
					RESULT = cP;
                :};
                
seccionParametros ::= declaracionParametros:dP{:		
						RESULT = new SeccionParametros(dP);;					
			        :} 
			        | epsilon;

declaracionParametros  ::= parametro:param COLON declaracionParametros:dP{:										
								dP.add(param);
								RESULT = dP;	 	
						 :}
                         | parametro:param {:                         
                         		DeclaracionParametros dP = new DeclaracionParametros();
                         		dP.add(param);
                         		RESULT = dP;                         
                         :};

parametro ::= ENTERO IDENTIFICADOR:id{:	
		          TypeIF tipo = scopeManager.searchType("ENTERO"); 					
				  RESULT = new Parametro(tipo, id.getLexema());		    	
            :} 
            | IDENTIFICADOR:iden IDENTIFICADOR:id {:            	
            	  if(!scopeManager.containsType(iden.getLexema())){
					  semanticErrorManager.semanticFatalError("Error en linea " + iden.getLine() + ": Tipo de parametro sin declarar");
				  }
				  
            	  TypeIF tipo = scopeManager.searchType(iden.getLexema());	
            	  
            	  if(!(tipo instanceof TypeSimpleEntero)){
					semanticErrorManager.semanticFatalError("Error en linea " + iden.getLine() + ": Los parametros deben ser de tipo entero");
				  }					
				  RESULT = new Parametro(tipo, id.getLexema());            
            :};



/* EXPRESIONES  *******************************************************************************************/

expresion ::= NUMERO:num{:
				
				Expresion exp = new Expresion(scopeManager.searchType("ENTERO"));
				ScopeIF scope = scopeManager.getCurrentScope();
				
				/*----- An·lisis sem·ntico -----*/
				
				exp.setValue(Integer.parseInt(num.getLexema()));				
				
				/*----- CÛdigo intermedio -----*/
				
				TemporalFactory tf = new TemporalFactory(scope);
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				TemporalIF temp = tf.create();
				
				cb.addQuadruple ("MV", temp, Integer.parseInt(num.getLexema()));
				
				exp.setTemporal(temp);
				exp.setIntermediateCode(cb.create());						
				RESULT = exp; 
				
			:}
            | IDENTIFICADOR:id{:
            	
            	Expresion exp = new Expresion(); 
            	ScopeIF scope = scopeManager.getCurrentScope();
            	
            	/*----- An·lisis sem·ntico -----*/
            	
                if(!scopeManager.containsSymbol(id.getLexema())){
                	semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": El simbolo '" + id.getLexema() + "' no ha sido declarado");
				}				
				SymbolIF symbol = scopeManager.searchSymbol(id.getLexema());
				exp.setType(symbol.getType()); 
				
				
				/*----- CÛdigo intermedio -----*/
				
				TemporalFactory tf = new TemporalFactory(scope);
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				TemporalIF temp = tf.create();
				
				if(symbol instanceof SymbolConstant){
					Value value = new Value(((SymbolConstant)symbol).getValue());
					cb.addQuadruple("MV",temp,value);
					exp.setValue(((SymbolConstant)symbol).getValue()); //para el acceso a vector
				}else if(symbol instanceof SymbolVariable){
					Variable var = new Variable((SymbolVariable)symbol);
					cb.addQuadruple("MVP",temp,var);
					exp.setValue(((SymbolVariable)symbol).getValue()); //para el acceso a vector
				}
				
				exp.setTemporal(temp);
				exp.setIntermediateCode(cb.create());						
				RESULT = exp; 		
									
            :}            
		    | OPEN_KEY expresion:e1 CLOSE_KEY {:  // esta se queda asi segun el pdf
		    	RESULT = e1; 
		    	
		    :}		        
			| expresion:e1 PLUS:op expresion:e2 {:	
				
				Expresion exp = new Expresion(); 
            	ScopeIF scope = scopeManager.getCurrentScope();
            	
				/*----- An·lisis sem·ntico -----*/
						 	
			 	if(!(e1.getType() instanceof TypeSimpleEntero) || !(e2.getType() instanceof TypeSimpleEntero)){
					semanticErrorManager.semanticFatalError("Error en linea " + op.getLine() + ": Incompatibilidad de tipos");
				}				
				exp.setType(e1.getType());
				
				/*----- CÛdigo intermedio -----*/
				
				TemporalFactory tf = new TemporalFactory(scope);
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				TemporalIF temp1 = e1.getTemporal();
				TemporalIF temp = tf.create();
				
				cb.addQuadruples (e1.getIntermediateCode());
				cb.addQuadruples (e2.getIntermediateCode());
				cb.addQuadruple ("ADD", temp, e1.getTemporal(), e2.getTemporal());
				
				exp.setTemporal(temp);
				exp.setIntermediateCode(cb.create());						
				RESULT = exp;
				
			:}						 	
			| expresion:e1 MULT:op expresion:e2 {:		
			
				Expresion exp = new Expresion(); 
            	ScopeIF scope = scopeManager.getCurrentScope();
            	
            	/*----- An·lisis sem·ntico -----*/
            		 	
			 	if(!(e1.getType() instanceof TypeSimpleEntero) || !(e2.getType() instanceof TypeSimpleEntero)){
					semanticErrorManager.semanticFatalError("Error en linea " + op.getLine() + ": Incompatibilidad de tipos");
				}				
				exp.setType(e1.getType());
				
				/*----- CÛdigo intermedio -----*/
				
				TemporalFactory tf = new TemporalFactory(scope);
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				TemporalIF temp = tf.create();
				
				cb.addQuadruples (e1.getIntermediateCode());
				cb.addQuadruples (e2.getIntermediateCode());
				cb.addQuadruple ("MUL", temp, e1.getTemporal(), e2.getTemporal());
				
				exp.setTemporal(temp);
				exp.setIntermediateCode(cb.create());						
				RESULT = exp;	
							
			:}			
		 	| expresion:e1 AUTO_INCREMENTO:op{:
		 		
		 		Expresion exp = new Expresion(); 
            	ScopeIF scope = scopeManager.getCurrentScope();
            	
            	/*----- An·lisis sem·ntico -----*/
						 	
			 	if(!(e1.getType() instanceof TypeSimpleEntero)){
					semanticErrorManager.semanticFatalError("Error en linea " + op.getLine() + ": Incompatibilidad de tipos");
				}				
				exp.setType(e1.getType());
				
		 		/*----- CÛdigo intermedio -----*/
				
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
								
				cb.addQuadruples (e1.getIntermediateCode());
				cb.addQuadruple ("INC", e1.getTemporal());
				
				exp.setTemporal(e1.getTemporal());
				exp.setIntermediateCode(cb.create());						
				RESULT = exp;				
		 		
		 	:}
		 	| NEGACION:op expresion:e1{:
		 	
		 		Expresion exp = new Expresion(); 
            	ScopeIF scope = scopeManager.getCurrentScope();
            	
            	/*----- An·lisis sem·ntico -----*/
            	
            	if(!(e1.getType() instanceof TypeSimpleEntero)){
					semanticErrorManager.semanticFatalError("Error en linea " + op.getLine() + ": Incompatibilidad de tipos");
				}
		 		exp.setType(e1.getType());
		 		
		 		/*----- CÛdigo intermedio -----*/
		 		
		 		TemporalFactory tf = new TemporalFactory(scope);
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				TemporalIF temp = tf.create();
				
				cb.addQuadruples (e1.getIntermediateCode ());
				cb.addQuadruple ("NOT", temp, e1.getTemporal());
				
				exp.setTemporal(temp);
				exp.setIntermediateCode(cb.create());						
				RESULT = exp;
				
		 	:}		 	
		 	| expresion:e1 LOWER_THAN:op expresion:e2{:			
		 		
		 		Expresion exp = new Expresion(); 
            	ScopeIF scope = scopeManager.getCurrentScope();
            	
            	/*----- An·lisis sem·ntico -----*/
            	 	
			 	if(!(e1.getType() instanceof TypeSimpleEntero) || !(e2.getType() instanceof TypeSimpleEntero)){
					semanticErrorManager.semanticFatalError("Error en linea " + op.getLine() + ": Incompatibilidad de tipos");
				}
				exp.setType(e1.getType());
				
				/*----- CÛdigo intermedio -----*/
				
				TemporalFactory tf = new TemporalFactory(scope);
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				TemporalIF temp = tf.create();
				
				cb.addQuadruples (e1.getIntermediateCode());
				cb.addQuadruples (e2.getIntermediateCode());
				cb.addQuadruple ("LS", temp, e1.getTemporal(), e2.getTemporal());
				
				exp.setTemporal(temp);
				exp.setIntermediateCode(cb.create());						
				RESULT = exp;
						
			:}
		 	| expresion:e1 EQUAL:op expresion:e2{:	
		 		
		 		Expresion exp = new Expresion(); 
            	ScopeIF scope = scopeManager.getCurrentScope();
            	
            	/*----- An·lisis sem·ntico -----*/
            		 		
		 		if(!(e1.getType() instanceof TypeSimpleEntero) || !(e2.getType() instanceof TypeSimpleEntero)){
					semanticErrorManager.semanticFatalError("Error en linea " + op.getLine() + ": Incompatibilidad de tipos");
				}
				exp.setType(e1.getType());
				
				
				/*----- CÛdigo intermedio -----*/
				
				TemporalFactory tf = new TemporalFactory(scope);
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				TemporalIF temp = tf.create();
				
				cb.addQuadruples (e1.getIntermediateCode());
				cb.addQuadruples (e2.getIntermediateCode());
				cb.addQuadruple ("EQ", temp, e1.getTemporal(), e2.getTemporal());
				
				exp.setTemporal(temp);
				exp.setIntermediateCode(cb.create());						
				RESULT = exp;
						 	
		 	:}
		 	| expresion:e1 AND_LOGICA:op expresion:e2{:		
		 		
		 		Expresion exp = new Expresion(); 
            	ScopeIF scope = scopeManager.getCurrentScope();
            	
            	/*----- An·lisis sem·ntico -----*/
            		 	
			 	if(!(e1.getType() instanceof TypeSimpleEntero) || !(e2.getType() instanceof TypeSimpleEntero)){
					semanticErrorManager.semanticFatalError("Error en linea " + op.getLine() + ": Incompatibilidad de tipos");
				}	
				exp.setType(e1.getType());
				
				/*----- CÛdigo intermedio -----*/
				
				TemporalFactory tf = new TemporalFactory(scope);
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				TemporalIF temp = tf.create();
				
				cb.addQuadruples (e1.getIntermediateCode());
				cb.addQuadruples (e2.getIntermediateCode());
				cb.addQuadruple ("AND", temp, e1.getTemporal(), e2.getTemporal());
				
				exp.setTemporal(temp);
				exp.setIntermediateCode(cb.create());						
				RESULT = exp;
						
			:}
		 	| accesoVector:aV{:
		 		
		 		Expresion exp = new Expresion(aV.getExpresion().getType()); 
            	ScopeIF scope = scopeManager.getCurrentScope();
            	
            	/*----- CÛdigo intermedio -----*/
            	
            	TemporalFactory tf = new TemporalFactory(scope);
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				TemporalIF temp = tf.create();
				TemporalIF tempAux = tf.create();
				
				cb.addQuadruples(aV.getIntermediateCode());
				cb.addQuadruple("MVP",temp,aV.getTemporal());
				cb.addQuadruple("LOAD",tempAux,temp);
				
				exp.setTemporal(tempAux);
				exp.setIntermediateCode(cb.create());	            	
		 	  	RESULT = exp;
		 	:}
			| llamadaFuncion:fun{:				
			    
			   
			    /*----- An·lisis sem·ntico -----*/
			    
				SymbolIF symbolFun = scopeManager.searchSymbol(fun.getName());
				if(!(symbolFun.getType() instanceof TypeSimpleEntero)){
					semanticErrorManager.semanticFatalError("Error: La funcion '" + fun.getName() + "' no devuelve un valor");
				}
				Expresion exp = new Expresion(symbolFun.getType());
				
				/*----- CÛdigo intermedio -----*/
				
				// Las expresiones que son funciones devuelven 1
				
				ScopeIF scope = scopeManager.getCurrentScope();
				TemporalFactory tf = new TemporalFactory(scope);
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				TemporalIF temp = tf.create();
				
				cb.addQuadruple ("MV", temp, 1);
				
				exp.setTemporal(temp);
				exp.setIntermediateCode(cb.create());															
				RESULT = exp;	
			:};


accesoVector ::= IDENTIFICADOR:id OPEN_BRACKET expresion:e CLOSE_BRACKET{:
                 	
                 	
            		ScopeIF scope = scopeManager.getCurrentScope();
            		
                 	/*----- An·lisis sem·ntico -----*/
                 	
                 	//comprobar que la variable existe y se trata de un vector
                 	if(!scopeManager.containsSymbol(id.getLexema())){
						semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": No existe " + id.getLexema());							
					}					
                 	SymbolIF symbol = scopeManager.searchSymbol(id.getLexema());
                 	
                 	if(!(symbol.getType() instanceof TypeArray)){
                 		semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": '" + id.getLexema() + "' no es un array");
                 	}
                 	TypeArray typeArray = (TypeArray)symbol.getType(); 
                 	
                 	//comprobar que expresion respeta el rango del vector                   	
                 	if(e.getValue() < 0 || e.getValue() > typeArray.getSize() -1){
                 		semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": acceso a '" + id.getLexema() + "' fuera de lÌmites");
                 	}                	          					
                 	
                 	AccesoVector aV = new AccesoVector(id.getLexema(), e);
                 	
                 	/*----- CÛdigo intermedio -----*/
                 	
                 	TemporalFactory tf = new TemporalFactory(scope);
					IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
					Variable var = new Variable((SymbolVariable)symbol);
             	    int elementSize = typeArray.getSize();             	    
             	                 	
                 	cb.addQuadruples(e.getIntermediateCode()); 
                 	TemporalIF temp = tf.create();
                 	TemporalIF tempSub = tf.create();
                 	TemporalIF tempBase = tf.create();
                 	
                 	// obtiene la direccion base del array  
                 	cb.addQuadruple("MVA", tempBase, var);     
                 	// calcula la direccion objetivo restando a la direccion base el offset                             	              	
                 	cb.addQuadruple("SUB", tempSub, tempBase, e.getTemporal());  
                 	
                 	aV.setIntermediateCode(cb.create());
                 	aV.setTemporal(tempSub);                                   
                 	RESULT = aV;
               :};

llamadaFuncion ::= IDENTIFICADOR:id OPEN_KEY parametros:param CLOSE_KEY{:					
				        
				        /*----- An·lisis sem·ntico -----*/
				        
				        //Comprobar si existe la funcion referenciada
				        if(!scopeManager.containsSymbol(id.getLexema())){
				            semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": La funciÛn '" + id.getLexema() + "' no ha sido declarada");
					    }
					    
					    // Verificar que se corresponden los parametros actuales y formales
						SymbolFunction sF = (SymbolFunction) scopeManager.searchSymbol(id.getLexema());
						
						if((sF.getParametros() == null) || (sF.getParametros().size() != param.getListaExpr().size())){
							semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": Incorrecto n˙mero de par·metros en '" + id.getLexema() + "'");
						}	
																
						for(int i = 0; i< sF.getParametros().size(); i++){					
							if(sF.getParametros().get(i).getType() != param.getListaExpr().get(i).getType()){
								semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": Incorrecto tipo/orden de par·metros en '" + id.getLexema() + "'");
							}
						}						
					   
					   RESULT = new LlamadaFuncion(id.getLexema(), param.getListaExpr()); 	
                 :}
	             | IDENTIFICADOR:id OPEN_KEY CLOSE_KEY{:
	             	   
	             	   /*----- An·lisis sem·ntico -----*/
	             	   	
	             	   if(!scopeManager.containsSymbol(id.getLexema())){
				          semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": La funciÛn '" + id.getLexema() + "' no ha sido declarada");
					   }
					   
					   // Verificar que se corresponden los parametros actuales y formales
					   SymbolFunction sF = (SymbolFunction) scopeManager.searchSymbol(id.getLexema());
						
					   if(sF.getParametros() != null){
							semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": Incorrecto n˙mero de par·metros en '" + id.getLexema() + "'");
				       }
						
					   RESULT = new LlamadaFuncion(id.getLexema()); 
                 :};
	
	
parametros ::= expresion:e{:
                    Parametros params = new Parametros();
                    params.add(e);                    
                    RESULT = params;                         
             :}
             | expresion:e COLON parametros:params{:             				   		
			   		params.add(e);
				    RESULT = params;	 	
			 :};



/* SENTENCIAS  *******************************************************************************************/

bloque ::= OPEN_PARENTHESIS {:

				// Crea ambito del bloque y obtener sus tablas						
				ScopeIF scope = scopeManager.openScope("bloque");
				SymbolTableIF symbolTable = scope.getSymbolTable();   // no lo necesito?
				TypeTableIF typeTable = scope.getTypeTable();		  // no lo necesito?					
			:}
			cuerpoBloque:cBlq CLOSE_PARENTHESIS	{:			
				
				Bloque blq = new Bloque(cBlq);
				
				/*----- CÛdigo intermedio -----*/
				
				ScopeIF scope = scopeManager.getCurrentScope();
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				
				cb.addQuadruples(cBlq.getIntermediateCode());				
							
				blq.setIntermediateCode(cb.create());
				RESULT = blq;	
				
				scopeManager.closeScope();							
			:};    	 

cuerpoBloque ::= listadoSentencias:lS{:

					CuerpoBloque cuerpoBlq = new CuerpoBloque(lS);
					
					/*----- CÛdigo intermedio -----*/
						
	                ScopeIF scope = scopeManager.getCurrentScope();
				   	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				   	
				   	cb.addQuadruples(lS.getIntermediateCode());
				   	
				   	cuerpoBlq.setIntermediateCode(cb.create());						
					RESULT = cuerpoBlq;
					
			   :}
			   | seccionVariables:sV listadoSentencias:lS{:
			   
					CuerpoBloque cuerpoBlq = new CuerpoBloque(lS,sV);
					
					/*----- CÛdigo intermedio -----*/
						
	                ScopeIF scope = scopeManager.getCurrentScope();
				   	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				   	
				   	cb.addQuadruples(sV.getIntermediateCode());
				   	cb.addQuadruples(lS.getIntermediateCode());
					
					cuerpoBlq.setIntermediateCode(cb.create());	
					RESULT = cuerpoBlq;
			   :};

listadoSentencias ::= listadoSentencias:lS sentencia:sent {:
						
						/*----- An·lisis sem·ntico -----*/
						
						if(sent instanceof SentenciaDevuelve  &&  ((SentenciaDevuelve)sent).getExpresion() != null){						
							lS.setDevuelve(true);									
						}
						lS.add(sent);			
						
						/*----- CÛdigo intermedio -----*/
						
	                    ScopeIF scope = scopeManager.getCurrentScope();
				   		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);				   		
	
				   		cb.addQuadruples(lS.getIntermediateCode()); 
				   		cb.addQuadruples(sent.getIntermediateCode());       
									
						lS.setIntermediateCode(cb.create());	
						RESULT = lS;
					:}
                    | sentencia:sent{:
                    
                    	ListadoSentencias lS = new ListadoSentencias();
                    	
                    	/*----- An·lisis sem·ntico -----*/
                    	
                    	if(sent instanceof SentenciaDevuelve && ((SentenciaDevuelve)sent).getExpresion() != null){						
							lS.setDevuelve(true);									
						}												
                    	lS.add(sent);
                    	
                    	/*----- CÛdigo intermedio -----*/
						
	                    ScopeIF scope = scopeManager.getCurrentScope();
				   		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				   		
				   		cb.addQuadruples(sent.getIntermediateCode());       
									
						lS.setIntermediateCode(cb.create());					   		
                    	RESULT = lS;
                    :};
                    
			 
sentencia ::= sentenciaDevuelve: sentDevl {: RESULT = sentDevl; :}
  	        | sentenciaIncremento:sentIncrm {: RESULT = sentIncrm; :}
	        | sentenciaAsignacion:sentAsign {: RESULT = sentAsign; :}
	        | sentenciaAsignacionSuma:sentAsignSum {: RESULT = sentAsignSum; :}
	        | sentenciaSi:sentSi {: RESULT = sentSi; :}
	        | sentenciaAlternativas:sentAlt {: RESULT = sentAlt; :}
	        | sentenciaMientras:sentMien {: RESULT = sentMien; :}
	        | sentenciaLlamadaFuncion:sentLlamFun {: RESULT = sentLlamFun; :}
	        | sentenciaSalida:sentSld {: RESULT = sentSld; :}
	        | bloque:blq {: RESULT = blq; :};

sentenciaDevuelve ::= DEVUELVE SEMI_COLON{:						 
						 
						 SentenciaDevuelve sentDvl = new SentenciaDevuelve();
						 
						 /*----- CÛdigo intermedio -----*/	
	                	 
	                	 ScopeIF scope = scopeManager.getCurrentScope();
						 TemporalFactoryIF tf = new TemporalFactory(scope);
						 LabelFactory lf = new LabelFactory();
						 IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);	
						 
						 RESULT = sentDvl;			  
					:}
	                | DEVUELVE:d expresion:e SEMI_COLON{:		
	                	  
	                	 SentenciaDevuelve sentDvl = new SentenciaDevuelve(e);
	                	 
	                	 if(!(e.getType() instanceof TypeSimpleEntero)){
							semanticErrorManager.semanticFatalError("Error en linea " + d.getLine() + ": La expresion devuelta debe ser de tipo entero");
						 }
				
	                	 /*----- CÛdigo intermedio -----*/	
	                	 
	                	 ScopeIF scope = scopeManager.getCurrentScope();
						 TemporalFactoryIF tf = new TemporalFactory(scope);
						 LabelFactory lf = new LabelFactory();
						 IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
						 
	                	 LabelIF l1 = lf.create(scope.getName());
	                	 cb.addQuadruples(e.getIntermediateCode());
	                	 cb.addQuadruple("RETURN",l1,e.getTemporal());
	                	 
	                	 sentDvl.setIntermediateCode(cb.create());
						 RESULT = sentDvl;					  
					:};

sentenciaIncremento ::= IDENTIFICADOR:id AUTO_INCREMENTO SEMI_COLON{:

							/*----- An·lisis sem·ntico -----*/
							
							// comprobar identificador ref existe 
							if(!scopeManager.containsSymbol(id.getLexema())){
								semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": El simbolo '" + id.getLexema() + "' no ha sido declarado");							
							}				
							SymbolIF symbol = scopeManager.searchSymbol(id.getLexema());			
							
							// comprobar que identificadpr es de un tipo que se puede autoincrementar										
							if(symbol instanceof SymbolConstant || symbol instanceof SymbolFunction || symbol.getType() instanceof TypeArray){
								semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": No es posible incrementar '" + id.getLexema() + "'");
							}													
							SentenciaIncremento sentIncrm = new SentenciaIncremento(id.getLexema());
							
							/*----- CÛdigo intermedio -----*/
							
							ScopeIF scope = scopeManager.getCurrentScope();
							IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);	
											
							Variable var = new Variable((SymbolVariable)symbol);													
							cb.addQuadruple("INC",var);
							
							sentIncrm.setIntermediateCode(cb.create());
							RESULT = sentIncrm;							
						
					  :};

sentenciaAsignacion ::= ref:r ASSIGN:a expresion:e SEMI_COLON{:							
							
							/*----- An·lisis sem·ntico -----*/
							
							// El lado derecho de la asignacion debe ser de tipo entero  
							if(!(e.getType() instanceof TypeSimpleEntero)){
								semanticErrorManager.semanticFatalError("Error en linea " + a.getLine() + ": AsignaciÛn de tipos incompatibles");
							}							
							SentenciaAsignacion sentAsign = new SentenciaAsignacion(r,e);
							
							/*----- CÛdigo intermedio -----*/
						
							ScopeIF scope = scopeManager.getCurrentScope();
							TemporalFactoryIF tf = new TemporalFactory(scope);
							IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);									
								
							cb.addQuadruples(r.getIntermediateCode());
							cb.addQuadruples(e.getIntermediateCode());						    
						    cb.addQuadruple("STP",r.getTemporal(),e.getTemporal());
						    				
							sentAsign.setIntermediateCode(cb.create());														
							RESULT = sentAsign;						
													
                      :};
                      
sentenciaAsignacionSuma ::= ref:r ASSIGN_SUMA:as expresion:e SEMI_COLON{:															
								
								/*----- An·lisis sem·ntico -----*/
								
								// El lado derecho de la asignacion debe ser de tipo entero  
								if(!(e.getType() instanceof TypeSimpleEntero)){
									semanticErrorManager.semanticFatalError("Error en linea " + as.getLine() + ": Incompatibilidad de tipos");
								}									
								SentenciaAsignacionSuma sentAsignSum = new SentenciaAsignacionSuma(r,e);
								
								/*----- CÛdigo intermedio -----*/								
						
								ScopeIF scope = scopeManager.getCurrentScope();
								TemporalFactoryIF tf = new TemporalFactory(scope);
								IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);									
								SymbolIF symbol = scopeManager.searchSymbol(r.getId());			
									
								TemporalIF temp = tf.create();		
								TemporalIF temp2 = tf.create();
									
								cb.addQuadruples(r.getIntermediateCode());
								cb.addQuadruples(e.getIntermediateCode());								
									
								if(symbol instanceof SymbolConstant){
									Value value = new Value(((SymbolConstant)symbol).getValue());
									cb.addQuadruple("MV",temp2,value);									
								}else if(symbol instanceof SymbolVariable){
									Variable var = new Variable((SymbolVariable)symbol);
									cb.addQuadruple("MVP",temp2,var);									
								}								
								cb.addQuadruple ("ADD", temp, temp2, e.getTemporal());												
								cb.addQuadruple("STP",r.getTemporal(),temp);                
					
								sentAsignSum.setIntermediateCode(cb.create());															
								RESULT = sentAsignSum;						
	                      :};


ref ::= IDENTIFICADOR:id {:     

			Ref ref = new Ref(id.getLexema());
						
			/*----- An·lisis sem·ntico -----*/
			
			// comprobar si ref existe 
			if(!scopeManager.containsSymbol(id.getLexema())){
				semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": El simbolo '" + id.getLexema() + "' no ha sido declarado");							
			}
			SymbolIF symbol = scopeManager.searchSymbol(id.getLexema());
			
			// comprobar que ref es de un tipo asignable					
			if(symbol instanceof SymbolConstant){
				semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": No es posible modificar una constante");
			}							
			if(symbol instanceof SymbolFunction){
				semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": No es posible asignar a una funcion");
			}
			if(symbol.getType() instanceof TypeArray){
				semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": No es posible hacer asignacion directa a vector");
			}	
			
			/*----- CÛdigo intermedio -----*/
			
			ScopeIF scope = scopeManager.getCurrentScope();
			TemporalFactory tf = new TemporalFactory(scope);
			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
			
			TemporalIF temp = tf.create();		
			
			if(symbol instanceof SymbolVariable){	  
				Variable var = new Variable((SymbolVariable)symbol);
				cb.addQuadruple ("MVA", temp, var);
			}else if(symbol instanceof SymbolParameter){
				Variable var = new Variable((SymbolParameter)symbol);
				cb.addQuadruple ("MVA", temp, var);
			}
			
			ref.setTemporal(temp);                
			ref.setIntermediateCode(cb.create());			
			RESULT = ref;
	  :}
      | accesoVector:aV{: 
      		
      		Ref ref = new Ref(aV);
      		
      		/*----- CÛdigo intermedio -----*/
			
			ScopeIF scope = scopeManager.getCurrentScope();
			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
			
			cb.addQuadruples(aV.getIntermediateCode());
			
			ref.setTemporal(aV.getTemporal());      
			ref.setIntermediateCode(cb.create());					
      		RESULT = ref;
      :}; 



sentenciaSi ::= SI:si OPEN_KEY expresion:e CLOSE_KEY sentencia:sSi SINO sentencia:sSino{:   
					
					
					/*----- An·lisis sem·ntico -----*/
					
					if(!(e.getType() instanceof TypeSimpleEntero)){
						semanticErrorManager.semanticFatalError("Error en linea " + si.getLine() + ": Expresion no v·lida");
					}
					SentenciaSi sentSi = new SentenciaSi(e, sSi, sSino);
					
					/*----- CÛdigo intermedio -----*/
					
					ScopeIF scope = scopeManager.getCurrentScope();
					IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);					
					LabelFactory lf = new LabelFactory();
					
					LabelIF labelFinSi = lf.create();       	  
					LabelIF labelSino = lf.create();        	   
							
					cb.addQuadruples(e.getIntermediateCode());     
					cb.addQuadruple("BRF1",e.getTemporal(),labelSino);  //si temporal es 0, saltar a etiqueta sino 
					cb.addQuadruples(sSi.getIntermediateCode());        //anadir codigo sentencias parte si					
					cb.addQuadruple("BR",labelFinSi);                   //salto a etiqueta finSi
					cb.addQuadruple("INL",labelSino);                   //etiqueta sino
					cb.addQuadruples(sSino.getIntermediateCode());      //anadir codigo sentencias parte sino
					cb.addQuadruple("INL",labelFinSi);			        //etiqueta fin si
					
					sentSi.setIntermediateCode(cb.create());					
					RESULT = sentSi;			
					
			  :}
	          | SI:si OPEN_KEY expresion:e CLOSE_KEY sentencia:sSi{:
	          		
	          		/*----- An·lisis sem·ntico -----*/
					
					if(!(e.getType() instanceof TypeSimpleEntero)){
						semanticErrorManager.semanticFatalError("Error en linea " + si.getLine() + ": Expresion no v·lida");
					}
					SentenciaSi sentSi = new SentenciaSi(e, sSi, null);
					
					/*----- CÛdigo intermedio -----*/
					
					ScopeIF scope = scopeManager.getCurrentScope();
					IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);					
					LabelFactory lf = new LabelFactory();
										
					LabelIF labelFinSi = lf.create();       	  
					
					cb.addQuadruples(e.getIntermediateCode());           //anadir codigo de la expresion
					cb.addQuadruple("BRF1",e.getTemporal(),labelFinSi);  //si temporal es 0, saltar a etiqueta sino 
					cb.addQuadruples(sSi.getIntermediateCode());         //anadir codigo sentencias parte si	
					cb.addQuadruple("BR",labelFinSi);                    //salto a etiqueta finSi
					cb.addQuadruple("INL",labelFinSi);			         //etiqueta fin si
					
					sentSi.setIntermediateCode(cb.create());					
					RESULT = sentSi;
	          
	          :};
	
sentenciaAlternativas ::= ALTENATIVAS:alt OPEN_KEY expresion:e CLOSE_KEY OPEN_PARENTHESIS casosAlternativa:cA porDefecto:pD CLOSE_PARENTHESIS{:
								
								SentenciaAlternativas sA = new SentenciaAlternativas(e,cA,pD);
								
								/*----- An·lisis sem·ntico -----*/
								
								if(!(e.getType() instanceof TypeSimpleEntero)){
									semanticErrorManager.semanticFatalError("Error en linea " + alt.getLine() + ": Expresion no v·lida");
								}
								
								/*----- CÛdigo intermedio -----*/
					
								ScopeIF scope = scopeManager.getCurrentScope();
								IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);	
								TemporalFactory tf = new TemporalFactory(scope);				
								LabelFactory lf = new LabelFactory();										
															
								cb.addQuadruples(e.getIntermediateCode()); 										
								TemporalIF tempEQ = tf.create();
								TemporalIF tempAUX = tf.create();
								
								// Compara el numero de cada caso con la expresion. Si hay 
								// coincidencia, genera el codigo intermedio del caso
								for (CasoAlt caso : cA.getCasos()) {				
															        
							        cb.addQuadruples(caso.getIntermediateCode());
							        cb.addQuadruple ("EQ", tempEQ, e.getTemporal(),caso.getTemporal());	  // compara temporales de expresion y caso		        
       
							        LabelIF labelFinCaso = lf.create();
							        cb.addQuadruple("BRF",tempEQ,labelFinCaso);               // si no se cumple la condicion, saltar a fin de caso
							        cb.addQuadruples(caso.getBloque().getIntermediateCode()); // generar codigo intermedio para el bloque del caso							        
							        cb.addQuadruple("MV",tempAUX,1);                          						        
							       	cb.addQuadruple("INL",labelFinCaso);			          // etiqueta fin caso									        
							    }
							    
							    // Si no hay coincidencia y existe porDefecto, se ejecuta 
							    if (pD != null) {		
							    	LabelIF labelFinDefault = lf.create();        						
        							cb.addQuadruple("BRF0",tempAUX,labelFinDefault);	       
							        cb.addQuadruples(pD.getBloque().getIntermediateCode());							        
							        cb.addQuadruple("INL", labelFinDefault);		
							    }						    
							    
							   	sA.setIntermediateCode(cb.create());
								RESULT = sA;
						:};



casosAlternativa ::= casosAlternativa:cA casoAlt:caso{:				
						
						cA.add(caso);
						
						/*----- CÛdigo intermedio -----*/
						
						ScopeIF scope = scopeManager.getCurrentScope();
				   		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				   		
				   		cb.addQuadruples(cA.getIntermediateCode());  
				   		cb.addQuadruples(caso.getIntermediateCode());       
						
						cA.setIntermediateCode(cb.create());
						RESULT = cA;
				   :}
                   | casoAlt:caso{:
                   
                   		CasosAlternativa cA = new CasosAlternativa();
                   		cA.add(caso);
                   		
                   		/*----- CÛdigo intermedio -----*/
                   		
                   		ScopeIF scope = scopeManager.getCurrentScope();
				   		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				   		
				   		cb.addQuadruples(caso.getIntermediateCode());
                   		cA.setIntermediateCode(cb.create());
                   		RESULT = cA;
                   :};



casoAlt ::= CASO NUMERO:num TWO_POINTS bloque:blq CORTE SEMI_COLON{:					
				
				int numero = Integer.parseInt(num.getLexema());
				CasoAlt cA = new CasoAlt(numero,blq);
				
				/*----- CÛdigo intermedio -----*/					
								
				ScopeIF scope = scopeManager.getCurrentScope();
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
							
				TemporalFactory tf = new TemporalFactory(scope);
				TemporalIF temp = tf.create();
				cb.addQuadruple ("MV", temp, Integer.parseInt(num.getLexema()));
				
				cA.setTemporal(temp);			
				cA.setIntermediateCode(cb.create());
				RESULT = cA;
          :};

porDefecto ::= PORDEFECTO TWO_POINTS bloque:blq CORTE SEMI_COLON{:			   		
			   		
			   		PorDefecto pD = new PorDefecto(blq);
			   		
			   		/*----- CÛdigo intermedio -----*/
			   		
			   		ScopeIF scope = scopeManager.getCurrentScope();
					IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
					
					cb.addQuadruples(blq.getIntermediateCode());
					
					pD.setIntermediateCode(cb.create());
			   		RESULT = pD;
			 :}
             | epsilon; 
             
  

sentenciaMientras ::= MIENTRAS:m OPEN_KEY expresion:e CLOSE_KEY sentencia:sent{:	  			
							
							/*----- An·lisis sem·ntico -----*/
					
							if(!(e.getType() instanceof TypeSimpleEntero)){
								semanticErrorManager.semanticFatalError("Error en linea " + m.getLine() + ": Expresion no v·lida");
							}
							SentenciaMientras sentM = new SentenciaMientras(e,sent);
							
							/*----- CÛdigo intermedio -----*/
							
							ScopeIF scope = scopeManager.getCurrentScope();
							IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);					
							LabelFactory lf = new LabelFactory();
									
							LabelIF labelIniWhile = lf.create();       	           
							LabelIF labelFinWhile = lf.create();                   
														
							cb.addQuadruple("INL", labelIniWhile);     	 			//etiqueta comienzo mientras
							cb.addQuadruples(e.getIntermediateCode());  			//anadir codigo de la expresion
							cb.addQuadruple("BRF1",e.getTemporal(),labelFinWhile);  //si temppral es 0, saltar a finWhile 
							cb.addQuadruples(sent.getIntermediateCode());  			//anadir codigo de la sentencia
							cb.addQuadruple("BR",labelIniWhile);            		//volver al inicio del while
							cb.addQuadruple("INL",labelFinWhile);           		//etiqueta fin while				
													
							sentM.setIntermediateCode(cb.create());	
							RESULT = sentM;
                    :};

sentenciaLlamadaFuncion ::= llamadaFuncion:fun SEMI_COLON:sc{:
								
								/*----- An·lisis sem·ntico -----*/
								
								// Verificar que la funcion es de tipo vacio	
								SymbolIF symbolFun = scopeManager.searchSymbol(fun.getName());
								if(!(symbolFun.getType() instanceof TypeSimpleVacio)){
									semanticErrorManager.semanticFatalError("Error en linea " + sc.getLine() + ": La funcion debe ser de tipo vacio");
								}									
								SentenciaLlamadaFuncion sentLlamFun = new SentenciaLlamadaFuncion(fun);								

								RESULT = sentLlamFun;
                          :};

sentenciaSalida ::= ESCRIBE OPEN_KEY opcionesEscribe:opEsc CLOSE_KEY SEMI_COLON{:
							
							SentenciaSalida sentSld = new SentenciaSalida();
							ScopeIF scope = scopeManager.getCurrentScope();
							
							/*----- An·lisis sem·ntico -----*/
								
							if(opEsc != null){
								sentSld.setOpcionEscribe(opEsc.getOpciones());								
							}
							
							/*----- CÛdigo intermedio -----*/
							
							TemporalFactory tf = new TemporalFactory(scope);
							IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
							LabelFactory lf = new LabelFactory();								
			
							LabelIF lb = lf.create();
							TemporalIF temp = tf.create();
							
							cb.addQuadruple("WRITESTR",temp,lb);
														
							// Guardamos la cadena en la lista para recuperarla al final del programa
							listaCadenas.add(new Quadruple("STR",new Label(opEsc.getOpciones()),lb));							
														
							sentSld.setIntermediateCode(cb.create());	
							RESULT = sentSld;
						
                  :}
	              | ESCRIBE_ENT OPEN_KEY opcionesEscribeEnt:opEscEnt CLOSE_KEY SEMI_COLON{:
	              			
	              			SentenciaSalida sentSld = new SentenciaSalida();
	              			ScopeIF scope = scopeManager.getCurrentScope();
	              			
	              			/*----- An·lisis sem·ntico -----*/
	              			
	              			if(opEscEnt != null){
								sentSld.setOpcionEscribeEntero(opEscEnt.getOpciones());								
							}
							
							/*----- CÛdigo intermedio -----*/
							
							
							IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);							
							cb.addQuadruples(opEscEnt.getOpciones().getIntermediateCode());
							cb.addQuadruple("WRITEINT",opEscEnt.getOpciones().getTemporal());
							
							sentSld.setIntermediateCode(cb.create());	
							RESULT = sentSld;							
                  :};
	
	
opcionesEscribe ::= epsilon 
                  | STRING:str {:                   
                    	RESULT = new OpcionesEscribe(str.getLexema()); 
                  :};
                  
opcionesEscribeEnt ::= epsilon 
                     | expresion:e {:                            						   
						   RESULT = new OpcionesEscribeEnt(e);						   
                     :};
                     
