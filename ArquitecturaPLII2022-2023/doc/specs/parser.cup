package compiler.syntax;

// Declaracion de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;

import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaracion del codigo de usuario

action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// Declaracion de terminales


terminal Token PLUS;
terminal Token AUTO_INCREMENTO;
terminal Token MULT;
terminal Token AND_LOGICA;
terminal Token OPEN_BRACKET;
terminal Token CLOSE_BRACKET;
terminal Token OPEN_PARENTHESIS;
terminal Token CLOSE_PARENTHESIS;
terminal Token OPEN_KEY;
terminal Token CLOSE_KEY;
terminal Token SEMI_COLON;
terminal Token COLON;
terminal Token TWO_POINTS;
terminal Token NEGACION;
terminal Token EQUAL;
terminal Token ASSIGN_SUMA;
terminal Token ASSIGN;
terminal Token LOWER_THAN;
terminal Token CASO;
terminal Token CONSTANTE;
terminal Token CORTE;
terminal Token ENTERO;
terminal Token ESCRIBE;
terminal Token ESCRIBE_ENT;
terminal Token ALTENATIVAS;
terminal Token MIENTRAS;
terminal Token PORDEFECTO;
terminal Token principal;
terminal Token DEVUELVE;
terminal Token SI;
terminal Token SINO;
terminal Token TIPO;
terminal Token VACIO;
terminal Token IDENTIFICADOR;
terminal Token NUMERO;
terminal Token STRING;


// Declaracion de no terminales

non terminal Program                 program;
non terminal Axiom                   initAxiom;
non terminal Axiom		             axiom;
non terminal FuncionPrincipal        funcionPrincipal;
non terminal Epsilon   			     epsilon;
non terminal SeccionFunciones        seccionFunciones;
non terminal Funcion 			     funcion;
non terminal                	     seccionParametros;
non terminal DeclaracionParametros   declaracionParametros;
non terminal Parametro			     parametro;
non terminal SeccionConstantes	     seccionConstantes;
non terminal DeclaracionConstante    declaracionConstante;
non terminal SeccionTipos		     seccionTipos;
non terminal DeclaracionTipo	     declaracionTipo;
non terminal 			             tamTipo;
non terminal SeccionVariables	     seccionVariables;
non terminal DeclaracionVariable     declaracionVariable;
non terminal ListadoIDs			     listadoIDs;
non terminal Id			             id;
non terminal Expresion               expresion;
non terminal AccesoVector 		     accesoVector;
non terminal LlamadaFuncion		     llamadaFuncion;
non terminal Bloque			         bloque;
non terminal ListadoSentencias       listadoSentencias;
non terminal Sentencia			     sentencia;
non terminal SentenciaIncremento     sentenciaIncremento;
non terminal SentenciaAsignacion     sentenciaAsignacion;
non terminal Ref			         ref;
non terminal SentenciaAsignacionSuma sentenciaAsignacionSuma;
non terminal SentenciaSi			 sentenciaSi;
non terminal SentenciaAlternativas   sentenciaAlternativas;
non terminal CasosAlternativa		 casosAlternativa;
non terminal CasoAlt			     casoAlt; 
non terminal PorDefecto			     porDefecto;
non terminal SentenciaMientras		 sentenciaMientras;
non terminal SentenciaLlamadaFuncion sentenciaLlamadaFuncion;
non terminal Parametros			     parametros;
non terminal SentenciaSalida         sentenciaSalida;
non terminal OpcionesEscribe         opcionesEscribe;
non terminal OpcionesEscribeEnt		 opcionesEscribeEnt;
non terminal SentenciaDevuelve		 sentenciaDevuelve;

non terminal cuerpoFuncion;
non terminal cuerpoBloque;

// Declaracion de relaciones de precedencia
precedence left 	OPEN_KEY, CLOSE_KEY;
precedence right	OPEN_BRACKET, CLOSE_BRACKET;
precedence left		AUTO_INCREMENTO, NEGACION;
precedence left		MULT;
precedence left		PLUS;
precedence left		LOWER_THAN;
precedence left		EQUAL;
precedence left     AND_LOGICA;
precedence nonassoc SINO;
precedence nonassoc SI;
            

// Declaracion de reglas de produccion


start with program;

program ::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   :}
  initAxiom:ax
  {:   		
  		// No modificar esta estructura, aunque se pueden a√±adir m√°s acciones sem√°nticas
  		
  		//List intermediateCode = ax.getIntermediateCode ();
  		//finalCodeFactory.create (intermediateCode);

  		// En caso de no comentarse las dos sentencias anteriores se puede generar una excepcion
  		// en las llamadas a cupTest si el compilador no est√° completo. Esto es debido a que 
  		// a√∫n no se tendr√° implementada la generaci√≥n de c√≥digo intermedio ni final.
  		// Para la entrega final deber√°n descomentarse y usarse.
  		
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
  		
   :};

initAxiom ::= {:
				// Creamos ambito global 							
				ScopeIF scope = scopeManager.openScope("global");
												
				// Obtener tablas de tipos e introducir tipos primitivos
				TypeTableIF typeTable = scope.getTypeTable();					
				TypeSimpleEntero tipoEntero = new TypeSimpleEntero(scope, "ENTERO");
				typeTable.addType("ENTERO", tipoEntero);
				TypeSimpleVacio tipoVacio = new TypeSimpleVacio(scope, "VACIO");
				typeTable.addType("VACIO", tipoVacio);							
		  	  :}
			
			  axiom
			
			  {:			
				// Cerrar ambito global
				ScopeIF scope = scopeManager.getCurrentScope();
				scopeManager.closeScope();				
		      :};

axiom ::= seccionConstantes seccionTipos seccionVariables seccionFunciones
        | seccionConstantes seccionTipos seccionFunciones;
 
 
//  CONSTANTES

seccionConstantes ::= declaracionConstante seccionConstantes | epsilon;
epsilon ::= ;

declaracionConstante ::= CONSTANTE IDENTIFICADOR:id NUMERO:value SEMI_COLON{:
							
							// Obtener ambito actual y tablas de simbolos y tipos 
							ScopeIF scope = scopeManager.getCurrentScope();
							SymbolTableIF tablaSimbolos = scope.getSymbolTable();
							TypeTableIF tablaTipos = scope.getTypeTable();
							String name = id.getLexema();
							
							// Comprobar que la constante no este ya declarada
							if(tablaSimbolos.containsSymbol(name)){
								semanticErrorManager.semanticFatalError("Constante " + name + " ya declarada");								
							}else{														
								// Introduce constante en tabla de simbolos	
								TypeIF tipo = scopeManager.searchType("ENTERO");  
								SymbolConstant symbolConstant = new SymbolConstant(scope, name, tipo);
								symbolConstant.setValue(value.getLexema()); 
								tablaSimbolos.addSymbol(symbolConstant);								
							}
					   :};

//  TIPOS 

seccionTipos ::= declaracionTipo seccionTipos | epsilon;

declaracionTipo ::= TIPO ENTERO IDENTIFICADOR:id OPEN_BRACKET tamTipo:tt CLOSE_BRACKET SEMI_COLON {:			      		 		
							
						// Obtener ambito actual y tablas de simbolos y tipos  
						ScopeIF scope = scopeManager.getCurrentScope();
						TypeTableIF tablaTipos = scope.getTypeTable();	
						String name = id.getLexema();
						int size = (int)tt;
						
						// Comprobar que el tipo no este ya declarado
						if(scopeManager.containsType(name)){
							semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": Tipo ya declarado");	
																			
						}else{								
							if( size < 1){
								semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": El tamano de un vector debe ser mayor que 0");
							}																									
							// Introducir tipo en tabla de tipos								
							TypeArray tipoVector = new TypeArray(scope, name, size);
							tablaTipos.addType(name, tipoVector);
												
						}
					:}; 

tamTipo ::= NUMERO:num {: 
				RESULT = Integer.parseInt(num.getLexema()); 
		  :}
          | IDENTIFICADOR:id {:          
                // Buscar la constante en el ambito                 
				SymbolTableIF tablaSimbolos = scopeManager.getCurrentScope().getSymbolTable();
				String name = id.getLexema();
				
				if(!scopeManager.containsSymbol(name)){
					semanticErrorManager.semanticFatalError("No existe la constante");
				}
				
				SymbolConstant c = (SymbolConstant)scopeManager.searchSymbol(name);
				RESULT = Integer.parseInt(c.getValue());					
          :};

//  VARIABLES

seccionVariables ::= seccionVariables declaracionVariable 
	               | declaracionVariable;
		
declaracionVariable ::= ENTERO listadoIDs:listaId SEMI_COLON{:
							
							// Obtener ambito actual y tabla de simbolos
							ScopeIF scope = scopeManager.getCurrentScope();
							SymbolTableIF tablaSimbolos = scope.getSymbolTable();
							
							// Anadir cada identificador a tabla de simbolos							
							for(Id id : listaId.getListaIds()){
								
								String idName = id.getName();
								int idValue = id.getValue();
								
								if(tablaSimbolos.containsSymbol(idName)){
									semanticErrorManager.semanticFatalError("Variable " + idName + " ya declarada");								
								}else{										
									TypeIF tipo = scopeManager.searchType("ENTERO");  
									SymbolVariable symbolVariable = new SymbolVariable(scope, idName, tipo);
									symbolVariable.setValue(idValue); 
									tablaSimbolos.addSymbol(symbolVariable);
								}
							}					
					   :}
					   
 	                  | IDENTIFICADOR:iden listadoIDs:listaId SEMI_COLON{:
							
							// Obtener ambito actual y tabla de simbolos 
							ScopeIF scope = scopeManager.getCurrentScope();
							SymbolTableIF tablaSimbolos = scope.getSymbolTable();				
							
							String type = iden.getLexema();
							
							// Anadir cada identificador a tabla de simbolos
							for(Id id : listaId.getListaIds()){
								
								String idName = id.getName();
																								
								if(tablaSimbolos.containsSymbol(idName)){
									semanticErrorManager.semanticFatalError("Variable " + idName + " ya declarada");								
								}else{									
									if(!scopeManager.containsType(type)){
										semanticErrorManager.semanticFatalError("Tipo no declarado");
									}									
									TypeIF tipo = scopeManager.searchType(type);  
									SymbolVariable symbolVariable = new SymbolVariable(scope, idName, tipo);							
									tablaSimbolos.addSymbol(symbolVariable);
								}
							}					
					   :};

listadoIDs ::= id:id  COLON listadoIDs:listaId {:			   		
			   		listaId.add(id);
			   		RESULT = listaId;
			 :}			 			 
			 | id:id{:			 
			   		ListadoIDs listaId = new ListadoIDs();
			   		listaId.add(id);
			   		RESULT = listaId;			 
			 :} ;

id ::= IDENTIFICADOR:id{:	      		   
            String name = id.getLexema();			
			RESULT = new Id(name, 0);						
     :}     
	 | IDENTIFICADOR:id ASSIGN NUMERO:num{:	   		
   			String name = id.getLexema();
			int value = Integer.parseInt(num.getLexema());			
			RESULT = new Id(name, value);					
     :};

// FUNCIONES

// Se han modificado las producciones de la funcion principal y las funciones para que
// ambas uilicen el no terminal "cuerpoFuncion" y asi evitar conflictos

seccionFunciones ::= funcion seccionFunciones | funcionPrincipal;

funcionPrincipal ::= VACIO principal OPEN_KEY CLOSE_KEY OPEN_PARENTHESIS                      
                     {:	
                     	//Declarar funcion principal en tabla de tipos y simbolos global                     	
                        ScopeIF globalScope = scopeManager.getCurrentScope();
                     	SymbolTableIF globalTablaSimbolos = globalScope.getSymbolTable();
						TypeTableIF globalTablaTipos = globalScope.getTypeTable();	
                     	
                     	TypeIF tipo = scopeManager.searchType("VACIO");  
						SymbolFunction symbolFunction = new SymbolFunction(globalScope, "principal", tipo);
						globalTablaSimbolos.addSymbol(symbolFunction);	
						TypeFunction typeFunction = new TypeFunction(globalScope, "principal");
						globalTablaTipos.addType("principal", typeFunction);
						
						// Crear ambito de la funcion principal y obtener sus tablas						
						ScopeIF scope = scopeManager.openScope("Funcion principal");							
						SymbolTableIF tablaSimbolos = scope.getSymbolTable();                      // las necesito?
						TypeTableIF tablaTipos = scope.getTypeTable();		
						
																						
				  	 :} 
				  	 
				  	 cuerpoFuncion CLOSE_PARENTHESIS 
				  	 
				  	 {:			
						//cerrar ambito 
						ScopeIF scope = scopeManager.getCurrentScope();
						scopeManager.closeScope();				
					 :};

funcion ::= ENTERO IDENTIFICADOR:id OPEN_KEY seccionParametros:sP CLOSE_KEY OPEN_PARENTHESIS
            {:
            	//Declarar funcion en tabla de tipos y tabla de simbolos global             	                  	
                ScopeIF globalScope = scopeManager.getCurrentScope();
                SymbolTableIF globalTablaSimbolos = globalScope.getSymbolTable();
				TypeTableIF globalTablaTipos = globalScope.getTypeTable();	
                     	
                TypeIF type = scopeManager.searchType("ENTERO");  
				SymbolFunction symbolFunction = new SymbolFunction(globalScope, id.getLexema(), type);
				globalTablaSimbolos.addSymbol(symbolFunction);	
				TypeFunction typeFunction = new TypeFunction(globalScope, id.getLexema());
				globalTablaTipos.addType(id.getLexema(), typeFunction);
            	
				// Crear ambito de la funcion y obtener sus tablas								
				ScopeIF scope = scopeManager.openScope("Funcion " + id.getLexema());					
				SymbolTableIF tablaSimbolos = scope.getSymbolTable();                         // las necesito?
				TypeTableIF tablaTipos = scope.getTypeTable();					
							
				
				//Declaracion de parametros en el ambito de la funcion					
				DeclaracionParametros listaParam = (DeclaracionParametros)sP;
				
				if(listaParam != null){						
					symbolFunction.setParametros(listaParam.getListaParam());									
					for(Parametro param : listaParam.getListaParam()){					 
						SymbolParameter symbolParameter = new SymbolParameter(scope, param.getName(), param.getType());							
						tablaSimbolos.addSymbol(symbolParameter);
					}
				}
													
			:} 
			 
			cuerpoFuncion CLOSE_PARENTHESIS
			
			{:			
				//cerrars ambito 
				ScopeIF scope = scopeManager.getCurrentScope();
				scopeManager.closeScope();				
			:}
			 
	      | VACIO IDENTIFICADOR:id OPEN_KEY seccionParametros:sP CLOSE_KEY OPEN_PARENTHESIS 
	        {:
	        	//Declarar funcion en tabla de tipos y tabla de simbolos global  	        	               	
                ScopeIF globalScope = scopeManager.getCurrentScope();
                SymbolTableIF globalTablaSimbolos = globalScope.getSymbolTable();
				TypeTableIF globalTablaTipos = globalScope.getTypeTable();	
                     	
                TypeIF type = scopeManager.searchType("VACIO");  
				SymbolFunction symbolFunction = new SymbolFunction(globalScope, id.getLexema(), type);
				globalTablaSimbolos.addSymbol(symbolFunction);	
				TypeFunction typeFunction = new TypeFunction(globalScope, id.getLexema());
				globalTablaTipos.addType(id.getLexema(), typeFunction);
				
				// Crea ambito de la funcion y obtener sus tablas									
				ScopeIF scope = scopeManager.openScope("Funcion " + id.getLexema());					
				SymbolTableIF tablaSimbolos = scope.getSymbolTable();                              // las necesito?
				TypeTableIF tablaTipos = scope.getTypeTable();
								
				//Declaracion de parametros en el ambito de la funcion	
				DeclaracionParametros listaParam = (DeclaracionParametros)sP;
				
				if(listaParam != null){			
				    symbolFunction.setParametros(listaParam.getListaParam());								
					for(Parametro param : listaParam.getListaParam()){							
						SymbolParameter symbolParameter = new SymbolParameter(scope, param.getName(), param.getType());							
						tablaSimbolos.addSymbol(symbolParameter);
					}				
				}											
			:} 
			 
			cuerpoFuncion CLOSE_PARENTHESIS
			
			{:			
				//cerrar ambito 
				ScopeIF scope = scopeManager.getCurrentScope();
				scopeManager.closeScope();				
			:};
			

cuerpoFuncion ::= seccionTipos listadoSentencias
                | seccionTipos seccionVariables listadoSentencias;
                
seccionParametros ::= declaracionParametros:listaParam{:						
						RESULT = listaParam;						
			        :} 
			        | epsilon;

declaracionParametros  ::= parametro:param COLON declaracionParametros:listaParam{:						   		
						   		listaParam.add(param);
						   		RESULT = listaParam;	 	
						 :}
                         | parametro:param {:
                         		DeclaracionParametros listaParam = new DeclaracionParametros();
                         		listaParam.add(param);
                         		RESULT = listaParam;                         
                         :};

parametro ::= ENTERO IDENTIFICADOR:id{:
				String name = id.getLexema();	
				TypeIF tipo = scopeManager.searchType("ENTERO"); 					
				RESULT = new Parametro(tipo, name);		    	
            :} 
            | IDENTIFICADOR:iden IDENTIFICADOR:id{:
            	
            	if(!scopeManager.containsType(iden.getLexema())){
					semanticErrorManager.semanticFatalError("Error en linea " + iden.getLine() + ": Tipo de parametro sin declarar");
				}
            	TypeIF tipo = scopeManager.searchType(iden.getLexema());
            	String name = id.getLexema();						
				RESULT = new Parametro(tipo, name);            
            :};



// EXPRESIONES

expresion ::= NUMERO{:
				RESULT = new Expresion(scopeManager.searchType("ENTERO"));
			:}
            | IDENTIFICADOR:id{:
                if(!scopeManager.containsSymbol(id.getLexema())){
                	semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": El simbolo '" + id.getLexema() + "' no ha sido declarado");
				}				
				SymbolIF symbol = scopeManager.searchSymbol(id.getLexema());				
				RESULT = new Expresion(symbol.getType()); 							
            :}            
		    | OPEN_KEY expresion:e1 CLOSE_KEY {:
		    	RESULT = e1; 
		    :}		        
			| expresion:e1 PLUS:op expresion:e2 {:			 	
			 	if(!(e1.getType() instanceof TypeSimpleEntero) || !(e2.getType() instanceof TypeSimpleEntero)){
					semanticErrorManager.semanticFatalError("Error en linea " + op.getLine() + ": Incompatibilidad de tipos");
				}				
				RESULT = new Expresion(e1.getType());
			:}			 	
			| expresion:e1 MULT:op expresion:e2 {:			 	
			 	if(!(e1.getType() instanceof TypeSimpleEntero) || !(e2.getType() instanceof TypeSimpleEntero)){
					semanticErrorManager.semanticFatalError("Error en linea " + op.getLine() + ": Incompatibilidad de tipos");
				}				
				RESULT = new Expresion(e1.getType());
			:}
		 	| expresion:e1 AUTO_INCREMENTO{:
		 		RESULT = new Expresion(e1.getType());
		 	:}
		 	| NEGACION expresion:e1{:
		 		RESULT = new Expresion(e1.getType());
		 	:}
		 	| expresion:e1 LOWER_THAN:op expresion:e2{:			 	
			 	if(!(e1.getType() instanceof TypeSimpleEntero) || !(e2.getType() instanceof TypeSimpleEntero)){
					semanticErrorManager.semanticFatalError("Error en linea " + op.getLine() + ": Incompatibilidad de tipos");
				}
				RESULT = new Expresion(e1.getType());			
			:}
		 	| expresion:e1 EQUAL:op expresion:e2{:		 		
		 		if(!(e1.getType() instanceof TypeSimpleEntero) || !(e2.getType() instanceof TypeSimpleEntero)){
					semanticErrorManager.semanticFatalError("Error en linea " + op.getLine() + ": Incompatibilidad de tipos");
				}
				RESULT = new Expresion(e1.getType());		 	
		 	:}
		 	| expresion:e1 AND_LOGICA:op expresion:e2{:			 	
			 	if(!(e1.getType() instanceof TypeSimpleEntero) || !(e2.getType() instanceof TypeSimpleEntero)){
					semanticErrorManager.semanticFatalError("Error en linea " + op.getLine() + ": Incompatibilidad de tipos");
				}	
				RESULT = new Expresion(e1.getType());			
			:}
		 	| accesoVector:aV{:
		 	  	RESULT = aV.getExpresion();
		 	:}
			| llamadaFuncion:fun{:				
			    // Verificar que la llamada a la funcion devuelve un tipo	
				SymbolIF symbolFun = scopeManager.searchSymbol(fun.getName());
				if(!(symbolFun.getType() instanceof TypeSimpleEntero)){
					semanticErrorManager.semanticFatalError("La funcion '" + fun.getName() + "' debe devolver un tipo");
				}	
												
				RESULT = new Expresion(symbolFun.getType());	
			:};


accesoVector ::= IDENTIFICADOR:id OPEN_BRACKET expresion:expr CLOSE_BRACKET{:
                 	
                 	//comprobar que la variable existe y se trata de un vector
                 	if(!scopeManager.containsSymbol(id.getLexema())){
						semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": No existe " + id.getLexema());							
					}
					
                 	SymbolIF symbol = scopeManager.searchSymbol(id.getLexema());
                 	
                 	if(!(symbol.getType() instanceof TypeArray)){
                 		semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": '" + id.getLexema() + "' no es un array");
                 	}
                 	
                 	//comprobar que expresion respeta el rango del vector                					
                 	
                 	RESULT = new AccesoVector(id.getLexema(), expr);
               :};

llamadaFuncion ::= IDENTIFICADOR:id OPEN_KEY parametros:param CLOSE_KEY{:					
				        
				        //Comprobar si existe la funcion referenciada
				        if(!scopeManager.containsSymbol(id.getLexema())){
				            semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": La funciÛn '" + id.getLexema() + "' no ha sido declarada");
					    }
					    
					    // Verificar que se corresponden los parametros actuales y formales
						SymbolFunction sF = (SymbolFunction) scopeManager.searchSymbol(id.getLexema());
						
						if(sF.getParametros().size() == param.getListaExpr().size()){											
							for(int i = 0; i< sF.getParametros().size(); i++){					
								if(sF.getParametros().get(i).getType() != param.getListaExpr().get(i).getType()){
									semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": Error en tipo/orden de los par·metros en '" + id.getLexema() + "'");
								}
							}					
						}else{
							semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": Error en el n˙mero de par·metros en '" + id.getLexema() + "'");
						}
					   
					   RESULT = new LlamadaFuncion(id.getLexema(), param.getListaExpr()); 	
                 :}
	             | IDENTIFICADOR:id OPEN_KEY CLOSE_KEY{:
	             	   if(!scopeManager.containsSymbol(id.getLexema())){
				          semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": La funciÛn '" + id.getLexema() + "' no ha sido declarada");
					   }
					   RESULT = new LlamadaFuncion(id.getLexema()); 
                 :};
	
	
parametros ::= expresion:expr{:
                    Parametros listaExpr = new Parametros();
                    listaExpr.add(expr);
                    RESULT = listaExpr;                         
             :}
             | expresion:expr COLON parametros:listaExpr{:						   		
			   		listaExpr.add(expr);
				    RESULT = listaExpr;	 	
			 :};

//  SENTENCIAS

bloque ::= OPEN_PARENTHESIS 
		   {:
				// Crea ambito del bloque y obtener sus tablas						
				ScopeIF scope = scopeManager.openScope("bloque");
				SymbolTableIF symbolTable = scope.getSymbolTable();
				TypeTableIF typeTable = scope.getTypeTable();								
			:}
			cuerpoBloque CLOSE_PARENTHESIS
			{:			
				//cerrar ambito 
				ScopeIF scope = scopeManager.getCurrentScope();
				scopeManager.closeScope();				
			:};    	 

cuerpoBloque ::= listadoSentencias
			   | seccionVariables listadoSentencias;

listadoSentencias ::= listadoSentencias:listaSent sentencia:sent {:
						listaSent.add(sent);
						RESULT = listaSent;
					:}
                    | sentencia:sent{:
                    	ListadoSentencias listaSent = new ListadoSentencias();
                    	listaSent.add(sent);
                    	RESULT = listaSent;
                    :};
                    
			 
sentencia ::= sentenciaDevuelve: sentDevl {: RESULT = sentDevl; :}
  	        | sentenciaIncremento:sentIncrm {: RESULT = sentIncrm; :}
	        | sentenciaAsignacion:sentAsign {: RESULT = sentAsign; :}
	        | sentenciaAsignacionSuma:sentAsignSum {: RESULT = sentAsignSum; :}
	        | sentenciaSi:sentSi {: RESULT = sentSi; :}
	        | sentenciaAlternativas:sentAlt {: RESULT = sentAlt; :}
	        | sentenciaMientras
	        | sentenciaLlamadaFuncion
	        | sentenciaSalida
	        | bloque;

sentenciaDevuelve ::= DEVUELVE SEMI_COLON{:						 
						 RESULT = new SentenciaDevuelve();					  
					:}
	                | DEVUELVE expresion:expr SEMI_COLON{:						 
						 RESULT = new SentenciaDevuelve(expr);					  
					:};

sentenciaIncremento ::= IDENTIFICADOR:id AUTO_INCREMENTO SEMI_COLON{:
							// comprobar identificador ref existe 
							if(!scopeManager.containsSymbol(id.getLexema())){
								semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": El simbolo '" + id.getLexema() + "' no ha sido declarado");							
							}
							
							// comprobar que identificadpr es de un tipo que se puede autoincrementar
							SymbolIF symbol = scopeManager.searchSymbol(id.getLexema());			
							if(symbol instanceof SymbolConstant){
								semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": No es posible modificar una constante");
							}							
							if(symbol instanceof SymbolFunction){
								semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": No es posible autoincrementar a una funcion");
							}
							if(symbol.getType() instanceof TypeArray){
								semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": No es posible autoincrementar vector");
							}
							
							SentenciaIncremento sentIncrm = new SentenciaIncremento(id.getLexema());
							RESULT = sentIncrm;
					  :};

sentenciaAsignacion ::= ref:r ASSIGN:a expresion:exp SEMI_COLON{:							
														
							// El lado derecho de la asignacion debe ser de tipo entero  
							if(!(exp.getType() instanceof TypeSimpleEntero)){
								semanticErrorManager.semanticFatalError("Error en linea " + a.getLine() + ": Incompatibilidad de tipos");
							}
							
							SentenciaAsignacion sentAsign = new SentenciaAsignacion(r,exp);
							RESULT = sentAsign;						
													
                      :};
                      
sentenciaAsignacionSuma ::= ref:r ASSIGN_SUMA:as expresion:exp SEMI_COLON{:															
								
								// El lado derecho de la asignacion debe ser de tipo entero  
								if(!(exp.getType() instanceof TypeSimpleEntero)){
									semanticErrorManager.semanticFatalError("Error en linea " + as.getLine() + ": Incompatibilidad de tipos");
								}	
								
								SentenciaAsignacionSuma sentAsignSum = new SentenciaAsignacionSuma(r,exp);
								RESULT = sentAsignSum;					
	                      :};


ref ::= IDENTIFICADOR:id {:
			// comprobar si ref existe 
			if(!scopeManager.containsSymbol(id.getLexema())){
				semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": El simbolo '" + id.getLexema() + "' no ha sido declarado");							
			}
			
			// comprobar que ref es de un tipo asignable
			SymbolIF symbol = scopeManager.searchSymbol(id.getLexema());			
			if(symbol instanceof SymbolConstant){
				semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": No es posible modificar una constante");
			}							
			if(symbol instanceof SymbolFunction){
				semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": No es posible asignar a una funcion");
			}
			if(symbol.getType() instanceof TypeArray){
				semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": No es posible hacer asignacion directa a vector");
			}	
			
			RESULT = new Ref(id.getLexema());
	  :}
      | accesoVector:aV{:
      		RESULT = new Ref(aV);
      :}; 


// puede contener una sentencia que puede ser un bloque con llaves
// si no hay llaves, es una sola sentencia y no se abre ambito

sentenciaSi ::= SI OPEN_KEY expresion:expr CLOSE_KEY sentencia:sSi SINO sentencia:sSino{:
					
					//comprobar la expresion. Se evalua como falsa si es 0 y verdadera si es distinto de 0
					
					SentenciaSi sentSi = new SentenciaSi(expr, sSi, sSino);
					RESULT = sentSi;			
						
			  :}
	          | SI OPEN_KEY expresion:expr CLOSE_KEY sentencia:sSi{:
	          		
	          		//comprobar la expresion. Se evalua como falsa si es 0 y verdadera si es distinto de 0
					
					SentenciaSi sentSi = new SentenciaSi(expr, sSi, null);
					RESULT = sentSi;
	          
	          :};
	
sentenciaAlternativas ::= ALTENATIVAS OPEN_KEY expresion:expr CLOSE_KEY OPEN_PARENTHESIS casosAlternativa:casosA porDefecto:porD CLOSE_PARENTHESIS{:
								
								SentenciaAlternativas sentAlt = new SentenciaAlternativas(expr, casosA, porD);
								RESULT = sentAlt;
						:};



casosAlternativa ::= casosAlternativa:casosA casoAlt:casoA{:						
						casosA.add(casoA);
						RESULT = casosA;
				   :}
                   | casoAlt:casoA{:
                   		CasosAlternativa casosA = new CasosAlternativa();
                   		casosA.add(casoA);
                   		RESULT = casosA;
                   :};

casoAlt ::= CASO NUMERO:num TWO_POINTS bloque:blq CORTE SEMI_COLON{:					
				int numero = Integer.parseInt(num.getLexema());
				RESULT = new CasoAlt(numero,blq);
          :};

porDefecto ::= PORDEFECTO TWO_POINTS bloque:blq CORTE SEMI_COLON{:			   		
			   		RESULT = new PorDefecto(blq);
			 :}
             | epsilon; 

sentenciaMientras ::= MIENTRAS OPEN_KEY expresion CLOSE_KEY sentencia;

sentenciaLlamadaFuncion ::= llamadaFuncion:fun SEMI_COLON:sc{:
								// Verificar que la funcion es de tipo vacio	
								SymbolIF symbolFun = scopeManager.searchSymbol(fun.getName());
								if(!(symbolFun.getType() instanceof TypeSimpleVacio)){
									semanticErrorManager.semanticFatalError("Error en linea " + sc.getLine() + ": La funcion debe ser de tipo vacio");
								}	
                          :};

sentenciaSalida ::= ESCRIBE OPEN_KEY opcionesEscribe CLOSE_KEY SEMI_COLON
	              | ESCRIBE_ENT OPEN_KEY opcionesEscribeEnt CLOSE_KEY SEMI_COLON;
	
	
opcionesEscribe ::= epsilon | STRING;
opcionesEscribeEnt ::= epsilon | expresion;
