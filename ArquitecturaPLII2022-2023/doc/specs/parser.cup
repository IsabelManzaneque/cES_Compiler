package compiler.syntax;

// Declaracion de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;

import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaracion del codigo de usuario

action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// Declaracion de terminales


terminal Token PLUS;
terminal Token AUTO_INCREMENTO;
terminal Token MULT;
terminal Token AND_LOGICA;
terminal Token OPEN_BRACKET;
terminal Token CLOSE_BRACKET;
terminal Token OPEN_PARENTHESIS;
terminal Token CLOSE_PARENTHESIS;
terminal Token OPEN_KEY;
terminal Token CLOSE_KEY;
terminal Token SEMI_COLON;
terminal Token COLON;
terminal Token TWO_POINTS;
terminal Token NEGACION;
terminal Token EQUAL;
terminal Token ASSIGN_SUMA;
terminal Token ASSIGN;
terminal Token LOWER_THAN;
terminal Token CASO;
terminal Token CONSTANTE;
terminal Token CORTE;
terminal Token ENTERO;
terminal Token ESCRIBE;
terminal Token ESCRIBE_ENT;
terminal Token ALTENATIVAS;
terminal Token MIENTRAS;
terminal Token PORDEFECTO;
terminal Token principal;
terminal Token DEVUELVE;
terminal Token SI;
terminal Token SINO;
terminal Token TIPO;
terminal Token VACIO;
terminal Token IDENTIFICADOR;
terminal Token NUMERO;
terminal Token STRING;


// Declaracion de no terminales

non terminal Program                 program;
non terminal Axiom                   initAxiom;
non terminal Axiom		             axiom;
non terminal FuncionPrincipal        funcionPrincipal;
non terminal Epsilon   			     epsilon;
non terminal SeccionFunciones        seccionFunciones;
non terminal Funcion 			     funcion;
non terminal SeccionParametros	     seccionParametros;
non terminal DeclaracionParametros   declaracionParametros;
non terminal Parametro			     parametro;
non terminal SeccionConstantes	     seccionConstantes;
non terminal DeclaracionConstante    declaracionConstante;
non terminal SeccionTipos		     seccionTipos;
non terminal DeclaracionTipo	     declaracionTipo;
non terminal TamTipo			     tamTipo;
non terminal SeccionVariables	     seccionVariables;
non terminal DeclaracionVariable     declaracionVariable;
non terminal ListadoIDs			     listadoIDs;
non terminal Id			             id;
non terminal Expresion               expresion;
non terminal AccesoVector		     accesoVector;
non terminal LlamadaFuncion		     llamadaFuncion;
non terminal Bloque			         bloque;
non terminal ListadoSentencias       listadoSentencias;
non terminal Sentencia			     sentencia;
non terminal SentenciaIncremento     sentenciaIncremento;
non terminal SentenciaAsignacion     sentenciaAsignacion;
non terminal Ref  			         ref;
non terminal SentenciaAsignacionSuma sentenciaAsignacionSuma;
non terminal SentenciaSi			 sentenciaSi;
non terminal SentenciaAlternativas   sentenciaAlternativas;
non terminal CasosAlternativa		 casosAlternativa;
non terminal CasoAlt			     casoAlt; 
non terminal PorDefecto			     porDefecto;
non terminal SentenciaMientras		 sentenciaMientras;
non terminal SentenciaLlamadaFuncion sentenciaLlamadaFuncion;
non terminal Parametros			     parametros;
non terminal SentenciaSalida         sentenciaSalida;
non terminal OpcionesEscribe         opcionesEscribe;
non terminal OpcionesEscribeEnt		 opcionesEscribeEnt;
non terminal SentenciaDevuelve		 sentenciaDevuelve;

non terminal cuerpoFuncion;
non terminal cuerpoBloque;

// Declaracion de relaciones de precedencia
precedence left 	OPEN_KEY, CLOSE_KEY;
precedence right	OPEN_BRACKET, CLOSE_BRACKET;
precedence left		AUTO_INCREMENTO, NEGACION;
precedence left		MULT;
precedence left		PLUS;
precedence left		LOWER_THAN;
precedence left		EQUAL;
precedence left     AND_LOGICA;
precedence nonassoc SINO;
precedence nonassoc SI;
            

// Declaracion de reglas de produccion


start with program;

program ::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   :}
  initAxiom:ax
  {:   		
  		// No modificar esta estructura, aunque se pueden a침adir m치s acciones sem치nticas
  		
  		//List intermediateCode = ax.getIntermediateCode ();
  		//finalCodeFactory.create (intermediateCode);

  		// En caso de no comentarse las dos sentencias anteriores se puede generar una excepcion
  		// en las llamadas a cupTest si el compilador no est치 completo. Esto es debido a que 
  		// a칰n no se tendr치 implementada la generaci칩n de c칩digo intermedio ni final.
  		// Para la entrega final deber치n descomentarse y usarse.
  		
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
  		
   :};

initAxiom ::= {:
				// Creamos ambito global 
				String idLexema  = "global";								
				ScopeIF scope = scopeManager.openScope(idLexema);
				
				System.out.println("Abriendo ambito: " + scope.getName() + ", Nivel: "+ scope.getLevel());
								
				// Obtenemos la tabla de tipos y la de simbolos 
				SymbolTableIF symbolTable = scope.getSymbolTable();
				TypeTableIF typeTable = scope.getTypeTable();				
		  	  :}
			
			  axiom
			
			  {:			
				//cerramos ambito global
				ScopeIF scope = scopeManager.getCurrentScope();
				System.out.println("Cerrando ambito: " + scope.getName() + ", Nivel: "+ scope.getLevel());
				scopeManager.closeScope();				
		      :};

axiom ::= seccionConstantes seccionTipos seccionVariables seccionFunciones
        | seccionConstantes seccionTipos seccionFunciones;
 
 
//  CONSTANTES

seccionConstantes ::= declaracionConstante seccionConstantes | epsilon;
epsilon ::= ;

declaracionConstante ::= CONSTANTE IDENTIFICADOR:id NUMERO:value SEMI_COLON{:
							
							// Obtenemos el ambito donde nos encontramos y obtenemos la tabla de simbolos 
							ScopeIF scope = scopeManager.getCurrentScope();
							SymbolTableIF tablaSimbolos = scope.getSymbolTable();
							String name = id.getLexema();
							
							// Comprobamos que la constante no este ya declarada en la tabla de simbolos
							if(tablaSimbolos.containsSymbol(name)){
								semanticErrorManager.semanticFatalError("Constante " + name + " ya declarada");								
							}else{
								System.out.println("Constante " + name + " aun NO declarada");
														
								// Introducimos en la tabla de simbolos la constante con su ambito, nombre, tipo y valor
								TypeTableIF tablaTipos = scope.getTypeTable();
								TypeIF tipo = scopeManager.searchType("ENTERO");  // en la pec de referencia las constantes eran todas enteras
								SymbolConstant symbolConstant = new SymbolConstant(scope, name, tipo);
								symbolConstant.setValue(value.getLexema()); // para esto se ha modificado la clase SymbolConstant en semantic.symbol
								tablaSimbolos.addSymbol(symbolConstant);								
							}
					   :};

//  TIPOS

seccionTipos ::= declaracionTipo seccionTipos | epsilon;
declaracionTipo ::= TIPO ENTERO IDENTIFICADOR OPEN_BRACKET tamTipo CLOSE_BRACKET SEMI_COLON;
tamTipo ::= NUMERO |  IDENTIFICADOR;

//  VARIABLES

seccionVariables ::= seccionVariables declaracionVariable 
	| declaracionVariable;
		
declaracionVariable ::= ENTERO listadoIDs SEMI_COLON
 	| IDENTIFICADOR listadoIDs SEMI_COLON;

listadoIDs ::=  id  COLON listadoIDs | id ;
id ::= IDENTIFICADOR | IDENTIFICADOR ASSIGN NUMERO;

// FUNCIONES

// Incluir las acciones sem烱ticas de abrir el 炅bito justo entre OPEN_PARENTHESIS cuerpoFuncion y cerrar el 炅bito despu乶 de CLOSE_PARENTHESIS.

seccionFunciones ::= funcion seccionFunciones | funcionPrincipal;

funcionPrincipal ::= VACIO principal OPEN_KEY CLOSE_KEY OPEN_PARENTHESIS                      
                     {:
						// Crea ambito de la funcion principal
						String idLexema  = "principal";								
						ScopeIF scope = scopeManager.openScope(idLexema);
						
						System.out.println("Abriendo ambito: " + scope.getName() + ", Nivel: "+ scope.getLevel());
						
						// Obtenemos la tabla de tipos y la de simbolos 
						SymbolTableIF symbolTable = scope.getSymbolTable();
						TypeTableIF typeTable = scope.getTypeTable();								
				  	 :} 
				  	 
				  	 cuerpoFuncion CLOSE_PARENTHESIS 
				  	 
				  	 {:			
						//cerramos ambito 
						ScopeIF scope = scopeManager.getCurrentScope();
						System.out.println("Cerrando ambito: " + scope.getName() + ", Nivel: "+ scope.getLevel());
						scopeManager.closeScope();				
					 :};

funcion ::= ENTERO IDENTIFICADOR OPEN_KEY seccionParametros CLOSE_KEY OPEN_PARENTHESIS
            {:
				// Crea ambito de la funcion 
				String idLexema  = "funcion";								
				ScopeIF scope = scopeManager.openScope(idLexema);
					
				System.out.println("Abriendo ambito: " + scope.getName() + ", Nivel: "+ scope.getLevel());
						
				// Obtenemos la tabla de tipos y la de simbolos 
				SymbolTableIF symbolTable = scope.getSymbolTable();
				TypeTableIF typeTable = scope.getTypeTable();								
			:} 
			 
			cuerpoFuncion CLOSE_PARENTHESIS
			
			{:			
				//cerramos ambito 
				ScopeIF scope = scopeManager.getCurrentScope();
				System.out.println("Cerrando ambito: " + scope.getName() + ", Nivel: "+ scope.getLevel());
				scopeManager.closeScope();				
			:}
			 
	      | VACIO IDENTIFICADOR OPEN_KEY seccionParametros CLOSE_KEY OPEN_PARENTHESIS 
	        {:
				// Crea ambito de la funcion 
				String idLexema  = "funcion";								
				ScopeIF scope = scopeManager.openScope(idLexema);
					
				System.out.println("Abriendo ambito: " + scope.getName() + ", Nivel: "+ scope.getLevel());
						
				// Obtenemos la tabla de tipos y la de simbolos 
				SymbolTableIF symbolTable = scope.getSymbolTable();
				TypeTableIF typeTable = scope.getTypeTable();								
			:} 
			 
			cuerpoFuncion CLOSE_PARENTHESIS
			
			{:			
				//cerramos ambito 
				ScopeIF scope = scopeManager.getCurrentScope();
				System.out.println("Cerrando ambito: " + scope.getName() + ", Nivel: "+ scope.getLevel());
				scopeManager.closeScope();				
			:};
			

cuerpoFuncion ::= seccionTipos listadoSentencias
                | seccionTipos seccionVariables listadoSentencias;
                
seccionParametros ::= declaracionParametros | epsilon;

declaracionParametros  ::= parametro | parametro COLON declaracionParametros;

parametro ::= ENTERO IDENTIFICADOR | IDENTIFICADOR IDENTIFICADOR;



// EXPRESIONES

expresion ::= NUMERO | IDENTIFICADOR
		    | OPEN_KEY expresion:e1 CLOSE_KEY {:		    	
		        Expresion e = new Expresion();  // generamos un objeto nuevo del tipo de la parte izq de la regla (en este caso, el antecedente es expresion y su clase Expresion)
		        RESULT = e; :}
		        
			| expresion:e1 PLUS expresion:e2 {:
			 	Expresion e = new Expresion(e1, e2);
			 	// comprobacion de tipos de e1 y e2
			 	// generacion de codigo de e1 + e2
			 	// ...
			 	RESULT = e;	:}
			 	
			| expresion MULT expresion
		 	| expresion AUTO_INCREMENTO
		 	| NEGACION expresion
		 	| expresion LOWER_THAN expresion
		 	| expresion EQUAL expresion
		 	| expresion AND_LOGICA expresion
		 	| accesoVector
			| llamadaFuncion;

accesoVector ::= IDENTIFICADOR OPEN_BRACKET expresion CLOSE_BRACKET;

llamadaFuncion ::= IDENTIFICADOR OPEN_KEY parametros CLOSE_KEY
	| IDENTIFICADOR OPEN_KEY CLOSE_KEY;
parametros ::= expresion | expresion COLON parametros;

//  SENTENCIAS

bloque ::= OPEN_PARENTHESIS 
		   {:
				// Crea ambito de la funcion 
				String idLexema  = "bloque";								
				ScopeIF scope = scopeManager.openScope(idLexema);
					
				System.out.println("Abriendo ambito: " + scope.getName() + ", Nivel: "+ scope.getLevel());
						
				// Obtenemos la tabla de tipos y la de simbolos 
				SymbolTableIF symbolTable = scope.getSymbolTable();
				TypeTableIF typeTable = scope.getTypeTable();								
			:}
			cuerpoBloque CLOSE_PARENTHESIS
			{:			
				//cerramos ambito 
				ScopeIF scope = scopeManager.getCurrentScope();
				System.out.println("Cerrando ambito: " + scope.getName() + ", Nivel: "+ scope.getLevel());
				scopeManager.closeScope();				
			:};    	 

cuerpoBloque ::= listadoSentencias
			   | seccionVariables listadoSentencias;

listadoSentencias ::= listadoSentencias sentencia | sentencia;

sentencia ::= sentenciaDevuelve
	| sentenciaIncremento
	| sentenciaAsignacion
	| sentenciaAsignacionSuma
	| sentenciaSi
	| sentenciaAlternativas
	| sentenciaMientras
	| sentenciaLlamadaFuncion
	| sentenciaSalida
	| bloque;

sentenciaDevuelve ::= DEVUELVE SEMI_COLON	
	| DEVUELVE expresion SEMI_COLON;

sentenciaIncremento ::= IDENTIFICADOR AUTO_INCREMENTO SEMI_COLON;

sentenciaAsignacion ::= ref ASSIGN expresion SEMI_COLON;
ref ::= IDENTIFICADOR | accesoVector;

sentenciaAsignacionSuma ::= ref ASSIGN_SUMA expresion SEMI_COLON;

sentenciaSi ::= SI OPEN_KEY expresion CLOSE_KEY sentencia SINO sentencia
	 | SI OPEN_KEY expresion CLOSE_KEY sentencia;
	
sentenciaAlternativas ::= ALTENATIVAS OPEN_KEY expresion CLOSE_KEY OPEN_PARENTHESIS casosAlternativa porDefecto CLOSE_PARENTHESIS;
casosAlternativa ::= casosAlternativa casoAlt | casoAlt;

casoAlt ::= CASO NUMERO TWO_POINTS bloque CORTE SEMI_COLON;
porDefecto ::= PORDEFECTO TWO_POINTS bloque CORTE SEMI_COLON | epsilon; 

sentenciaMientras ::= MIENTRAS OPEN_KEY expresion CLOSE_KEY sentencia;

sentenciaLlamadaFuncion ::= llamadaFuncion SEMI_COLON;

sentenciaSalida ::=ESCRIBE OPEN_KEY opcionesEscribe CLOSE_KEY SEMI_COLON
	| ESCRIBE_ENT OPEN_KEY opcionesEscribeEnt CLOSE_KEY SEMI_COLON;
opcionesEscribe ::= epsilon | STRING;
opcionesEscribeEnt ::= epsilon | expresion;
