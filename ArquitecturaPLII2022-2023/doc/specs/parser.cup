package compiler.syntax;

// Declaracion de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;

import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaracion del codigo de usuario

action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();
	
	// Lista para almacenar las cadenas de caracteres
	List<QuadrupleIF> listaCadenas = new ArrayList<>();

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// Declaracion de terminales


terminal Token PLUS;
terminal Token AUTO_INCREMENTO;
terminal Token MULT;
terminal Token AND_LOGICA;
terminal Token OPEN_BRACKET;
terminal Token CLOSE_BRACKET;
terminal Token OPEN_PARENTHESIS;
terminal Token CLOSE_PARENTHESIS;
terminal Token OPEN_KEY;
terminal Token CLOSE_KEY;
terminal Token SEMI_COLON;
terminal Token COLON;
terminal Token TWO_POINTS;
terminal Token NEGACION;
terminal Token EQUAL;
terminal Token ASSIGN_SUMA;
terminal Token ASSIGN;
terminal Token LOWER_THAN;
terminal Token CASO;
terminal Token CONSTANTE;
terminal Token CORTE;
terminal Token ENTERO;
terminal Token ESCRIBE;
terminal Token ESCRIBE_ENT;
terminal Token ALTENATIVAS;
terminal Token MIENTRAS;
terminal Token PORDEFECTO;
terminal Token principal;
terminal Token DEVUELVE;
terminal Token SI;
terminal Token SINO;
terminal Token TIPO;
terminal Token VACIO;
terminal Token IDENTIFICADOR;
terminal Token NUMERO;
terminal Token STRING;


// Declaracion de no terminales

non terminal Program                 program;
non terminal Axiom	                 axiom;
non terminal Axiom2                  axiom2;
non terminal FuncionPrincipal        funcionPrincipal;
non terminal Epsilon   			     epsilon;
non terminal SeccionFunciones        seccionFunciones;
non terminal Funcion 			     funcion;
non terminal SeccionParametros	     seccionParametros;
non terminal DeclaracionParametros   declaracionParametros;
non terminal Parametro			     parametro;
non terminal SeccionConstantes	     seccionConstantes;
non terminal DeclaracionConstante    declaracionConstante;
non terminal SeccionTipos		     seccionTipos;
non terminal DeclaracionTipo	     declaracionTipo;
non terminal 			             tamTipo;
non terminal SeccionVariables	     seccionVariables;
non terminal DeclaracionVariable     declaracionVariable;
non terminal ListadoIDs			     listadoIDs;
non terminal Id			             id;
non terminal Expresion               expresion;
non terminal AccesoVector 		     accesoVector;
non terminal LlamadaFuncion		     llamadaFuncion;
non terminal Bloque			         bloque;
non terminal ListadoSentencias       listadoSentencias;
non terminal Sentencia			     sentencia;
non terminal SentenciaIncremento     sentenciaIncremento;
non terminal SentenciaAsignacion     sentenciaAsignacion;
non terminal Ref			         ref;
non terminal SentenciaAsignacionSuma sentenciaAsignacionSuma;
non terminal SentenciaSi			 sentenciaSi;
non terminal SentenciaAlternativas   sentenciaAlternativas;
non terminal CasosAlternativa		 casosAlternativa;
non terminal CasoAlt			     casoAlt; 
non terminal PorDefecto			     porDefecto;
non terminal SentenciaMientras		 sentenciaMientras;
non terminal SentenciaLlamadaFuncion sentenciaLlamadaFuncion;
non terminal Parametros			     parametros;
non terminal SentenciaSalida         sentenciaSalida;
non terminal OpcionesEscribe         opcionesEscribe;
non terminal OpcionesEscribeEnt		 opcionesEscribeEnt;
non terminal SentenciaDevuelve		 sentenciaDevuelve;

non terminal CuerpoFuncion cuerpoFuncion;
non terminal CuerpoBloque cuerpoBloque;

// Declaracion de relaciones de precedencia
precedence left     AND_LOGICA;
precedence left		EQUAL;
precedence left		LOWER_THAN;
precedence left		PLUS;
precedence left		MULT;
precedence left		AUTO_INCREMENTO, NEGACION;
precedence right	OPEN_BRACKET, CLOSE_BRACKET;
precedence left 	OPEN_KEY, CLOSE_KEY;
precedence nonassoc SINO;
precedence nonassoc SI;
            

// Declaracion de reglas de produccion


start with program;

program ::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   :}
  axiom:ax
  {:   	
  		// Muestra las cuadruplas que llegan al axioma
  		String cuadruplas = "";
		List<QuadrupleIF> ic = ax.getIntermediateCode();

		for(QuadrupleIF q : ic){
			cuadruplas += q.toString() + "\n";
		}
		//semanticErrorManager.semanticDebug ("***** CUADRUPLAS *****: \n" + cuadruplas);
		
  		// No modificar esta estructura, aunque se pueden aÃ±adir mÃ¡s acciones semÃ¡nticas
  		
  		List intermediateCode = ax.getIntermediateCode ();
  		finalCodeFactory.setEnvironment(CompilerContext.getExecutionEnvironment());
  		finalCodeFactory.create (intermediateCode);

  		// En caso de no comentarse las dos sentencias anteriores se puede generar una excepcion
  		// en las llamadas a cupTest si el compilador no estÃ¡ completo. Esto es debido a que 
  		// aÃºn no se tendrÃ¡ implementada la generaciÃ³n de cÃ³digo intermedio ni final.
  		// Para la entrega final deberÃ¡n descomentarse y usarse.
  		
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
  		
   :};

axiom ::= {:
				// Creamos ambito global 							
				ScopeIF scope = scopeManager.openScope("global");
												
				// Obtener tablas de tipos e introducir tipos primitivos
				TypeTableIF typeTable = scope.getTypeTable();					
				TypeSimpleEntero tipoEntero = new TypeSimpleEntero(scope, "ENTERO");
				typeTable.addType("ENTERO", tipoEntero);
				TypeSimpleVacio tipoVacio = new TypeSimpleVacio(scope, "VACIO");
				typeTable.addType("VACIO", tipoVacio);							
		  	  :}
			
			  axiom2:ax2 {:
			  	 
			  	Axiom axiom = new Axiom();			  	
			  	
			  	// Asignacion de posiciones de memoria para variables globales y temporales
			  	
			  	int dirEstatica = 65535;
			  	
			  	for(ScopeIF s : scopeManager.getAllScopes()){  		
			  					  							  		
			  		for(SymbolIF sim : s.getSymbolTable().getSymbols()){			  			
			  			if(sim instanceof SymbolVariable){
			  				// guardamos la direccion en SymbolVariable.java y actualizamos dir
			  				((SymbolVariable)sim).setAddress(dirEstatica);
			  				dirEstatica -= sim.getType().getSize();			  				
			  			}
			  		}			  		
			  		for(TemporalIF temp : s.getTemporalTable().getTemporals()){
			  			if(temp instanceof Temporal){
			  				// guardamos la direccion en Temporal.java y actualizamos dir
			  				((Temporal)temp).setAddress(dirEstatica);
			  				dirEstatica -= ((Temporal)temp).getSize();
			  			}
			  		}
			  	}
			  	
			  	/*----- Código intermedio -----*/
			  	
			  	ScopeIF scope = scopeManager.getCurrentScope(); 
			  	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);				  	 
			  	cb.addQuadruples(ax2.getIntermediateCode());
			  	
			  	//finalizacion del programa
			  	cb.addQuadruple("HALT");
			  	//anadir las cadenas al final del programa			  	
			  	for(QuadrupleIF q : listaCadenas){
			  		cb.addQuadruple(q);
			  	}			  				  	
			  	
			  	axiom.setIntermediateCode(cb.create());
			  	RESULT = axiom;	
			  				
				// Cerrar ambito global
				scopeManager.closeScope();	
						
		      :};

//sT.getListaTipos().forEach((n) -> System.out.println(n));

axiom2 ::= seccionConstantes:sC seccionTipos:sT seccionVariables:sV seccionFunciones:sF{:
		     
		     Axiom2 axiom2 = new Axiom2(sC,sT,sV,sF);
		     
		     /*----- Código intermedio -----*/
						   		
		   	 ScopeIF scope = scopeManager.getCurrentScope();
			 IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
			 
		//	 if(sC != null){cb.addQuadruples(sC.getIntermediateCode());}
			 cb.addQuadruples(sV.getIntermediateCode());
			 cb.addQuadruples(sF.getIntermediateCode());
		     
		     axiom2.setIntermediateCode(cb.create());
		     RESULT = axiom2;
		 :}
	     | seccionConstantes:sC seccionTipos:sT seccionFunciones:sF{:
	       	 
	       	 Axiom2 axiom2 = new Axiom2(sC,sT,sF);
	       	 
	       	 /*----- Código intermedio -----*/
						   		
		   	 ScopeIF scope = scopeManager.getCurrentScope();
			 IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
			 
			// if(sC != null){cb.addQuadruples(sC.getIntermediateCode());}
			 cb.addQuadruples(sF.getIntermediateCode());
	       	 
	       	 axiom2.setIntermediateCode(cb.create());
		     RESULT = axiom2;
		 :};
 
                 
//  CONSTANTES
    

seccionConstantes ::= declaracionConstante:dec seccionConstantes:sC{:

						  if(sC == null){							    			     
						  	sC = new SeccionConstantes();		
						  }
						  sC.add(dec);	
						  
						  /*----- Código intermedio -----*/
						  			  
					//	  ScopeIF scope = scopeManager.getCurrentScope();
				   	//	  IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);			 
				   		  
				   	//	  cb.addQuadruples(sC.getIntermediateCode());  //anadir el codigo de las constantes ya generadas
				   	//	  cb.addQuadruples(dec.getIntermediateCode());       //anadir el codigo de la nueva constante
				   		  
				   	//	  sC.setIntermediateCode(cb.create()); 
						  RESULT = sC;
                    :}
                    | epsilon;
epsilon ::= ;

declaracionConstante ::= CONSTANTE IDENTIFICADOR:id NUMERO:value SEMI_COLON{:  	      		 	
							
							ScopeIF scope = scopeManager.getCurrentScope();
							DeclaracionConstante dC = new DeclaracionConstante();
							
							/*----- Análisis semántico -----*/
							
							SymbolTableIF tablaSimbolos = scope.getSymbolTable();
							TypeTableIF tablaTipos = scope.getTypeTable();
														
							// Comprobar que la constante no este ya declarada
							if(tablaSimbolos.containsSymbol(id.getLexema())){
								semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": constante '" + id.getLexema() + "' ya declarada");								
							}	
																				
							TypeIF tipo = scopeManager.searchType("ENTERO");  
							SymbolConstant symbolConstant = new SymbolConstant(scope, id.getLexema(), tipo);
							symbolConstant.setValue(Integer.parseInt(value.getLexema())); 
							tablaSimbolos.addSymbol(symbolConstant);	
							dC.setSymbolConstant(symbolConstant);
														
							/*----- Código intermedio -----*/							
							
							//IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);							
							
							//Value val = new Value(symbolConstant.getValue());
							//cb.addQuadruple("CONST",val);
							
							//dC.setIntermediateCode(cb.create());														
							RESULT = dC;							
					   :};

//  TIPOS 

seccionTipos ::= declaracionTipo:decTip seccionTipos:secTip{:	
					if(secTip == null){			
						secTip = new SeccionTipos();
					}  
					secTip.add(decTip);       
					RESULT = secTip;
               :} 
               | epsilon;

declaracionTipo ::= TIPO ENTERO IDENTIFICADOR:id OPEN_BRACKET tamTipo:tt CLOSE_BRACKET SEMI_COLON {:		      		 		
							
						// Obtener ambito actual y tablas de simbolos y tipos  
						ScopeIF scope = scopeManager.getCurrentScope();
						TypeTableIF tablaTipos = scope.getTypeTable();	

												
						// Comprobar que el tipo no este ya declarado y el tamano sea mayor que 0
						int size = (int)tt;
						if(scopeManager.containsType(id.getLexema())){
							semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": Tipo '" +id.getLexema()+"' ya declarado");																				
						}								
						if( size < 1){
							semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": El tamano de un vector debe ser mayor que 0");
						}	
																														
						// Introducir tipo en tabla de tipos								
						TypeArray tipoVector = new TypeArray(scope, id.getLexema(), size);
						tablaTipos.addType(id.getLexema(), tipoVector);
							
						RESULT = new DeclaracionTipo(tipoVector);							
					:}; 

tamTipo ::= NUMERO:num {: 
				RESULT = Integer.parseInt(num.getLexema()); 
		  :}
          | IDENTIFICADOR:id {:          
                // Buscar la constante en el ambito                 
				SymbolTableIF tablaSimbolos = scopeManager.getCurrentScope().getSymbolTable();
				if(!scopeManager.containsSymbol(id.getLexema())){
					semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": No existe la constante '" + id.getLexema() + "'");
				}
				
				SymbolConstant c = (SymbolConstant)scopeManager.searchSymbol(id.getLexema());
				RESULT = c.getValue();					
          :};



//  VARIABLES

seccionVariables ::= seccionVariables:sV declaracionVariable:dec{:

						sV.add(dec);
						
						/*----- Código intermedio -----*/
						
						ScopeIF scope = scopeManager.getCurrentScope();
				   		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				   		
				   		cb.addQuadruples(sV.getIntermediateCode());  
				   		cb.addQuadruples(dec.getIntermediateCode());       
				   		
				   		sV.setIntermediateCode(cb.create());
						RESULT = sV;
				   :}
	               | declaracionVariable:dec{:
	               		
	               		SeccionVariables sV = new SeccionVariables();
	               		sV.add(dec);
	               		
	               		/*----- Código intermedio -----*/
	               		
	               		ScopeIF scope = scopeManager.getCurrentScope();
				   		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
	               		
	               		cb.addQuadruples(dec.getIntermediateCode());
	               
	               		sV.setIntermediateCode(cb.create());
						RESULT = sV;
				   :};
				   
		
declaracionVariable ::= ENTERO listadoIDs:lIDs SEMI_COLON:sc{:  							
														
							ScopeIF scope = scopeManager.getCurrentScope();
							SymbolTableIF tablaSimbolos = scope.getSymbolTable();
							IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);														
							
							// Anadir cada identificador a tabla de simbolos							
							for(Id id : lIDs.getListaIds()){								
								
								DeclaracionVariable dV = new DeclaracionVariable();
								
								/*----- Análisis semántico -----*/
												
								if(tablaSimbolos.containsSymbol(id.getName())){
									semanticErrorManager.semanticFatalError("Error en linea " + sc.getLine() + ": variable '" + id.getName() + "' ya declarada");								
								}	
																	
								TypeIF tipo = scopeManager.searchType("ENTERO");  
								SymbolVariable symbolVariable = new SymbolVariable(scope, id.getName(), tipo);
								symbolVariable.setValue(id.getValue()); 
								tablaSimbolos.addSymbol(symbolVariable);
								dV.setSymbolVariable(symbolVariable);								
								
								/*----- Código intermedio -----*/								
								
								Variable var = new Variable(symbolVariable);								
								cb.addQuadruple("VAR",var,symbolVariable.getValue());								
								
								dV.setIntermediateCode(cb.create());
								RESULT = dV;								
							}					
					   :}
					   
 	                  | IDENTIFICADOR:iden listadoIDs:lIDs SEMI_COLON:sc{:
							
							ScopeIF scope = scopeManager.getCurrentScope();
							SymbolTableIF tablaSimbolos = scope.getSymbolTable();
							IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);				
							
							// Anadir cada identificador a tabla de simbolos
							for(Id id : lIDs.getListaIds()){
								
								DeclaracionVariable dV = new DeclaracionVariable();
								
								/*----- Análisis semántico -----*/
														
								if(tablaSimbolos.containsSymbol(id.getName())){
									semanticErrorManager.semanticFatalError("Error en linea " + sc.getLine() + ": variable '" + id.getName() + "' ya declarada");								
								}																	
								if(!scopeManager.containsType(iden.getLexema())){
									semanticErrorManager.semanticFatalError("Error en linea " + sc.getLine() + ": tipo '" + iden.getLexema() + "' no declarado");
								}	
																
								TypeIF tipo = scopeManager.searchType(iden.getLexema());  
								SymbolVariable symbolVariable = new SymbolVariable(scope, id.getName(), tipo);							
								tablaSimbolos.addSymbol(symbolVariable);
								dV.setSymbolVariable(symbolVariable);
								
								/*----- Código intermedio -----*/								
								
								Variable var = new Variable(symbolVariable);								
								cb.addQuadruple("VAR",var);								
							
								dV.setIntermediateCode(cb.create());
								RESULT = dV;	
							}					
					   :};

listadoIDs ::= id:id COLON listadoIDs:listaId {:			   		
			   		listaId.add(id);
			   		RESULT = listaId;
			 :}			 			 
			 | id:id{:			 
			   		ListadoIDs listaId = new ListadoIDs();
			   		listaId.add(id);
			   		RESULT = listaId;			 
			 :} ;

id ::= IDENTIFICADOR:id{:	      		   
            String name = id.getLexema();			
			RESULT = new Id(name, 0);						
     :}     
	 | IDENTIFICADOR:id ASSIGN NUMERO:num{:	   		
   			String name = id.getLexema();
			int value = Integer.parseInt(num.getLexema());			
			RESULT = new Id(name, value);					
     :};



// FUNCIONES

// Se han modificado las producciones de la funcion principal y las funciones para que
// ambas uilicen el no terminal "cuerpoFuncion" y asi evitar conflictos

      
seccionFunciones ::= funcion:fun seccionFunciones:sF{:

                        sF.addFuncion(fun);
                        
                        /*----- Código intermedio -----*/
						
	                    //ScopeIF scope = scopeManager.getCurrentScope();
				   		//IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);	
				   		
				   		//cb.addQuadruples(sF.getIntermediateCode());  //anadir el codigo de las funciones ya generadas
				   		//cb.addQuadruples(fun.getIntermediateCode());       //anadir el codigo de la nueva funcion
				   		
				   		//sF.setIntermediateCode(cb.create());
                        RESULT = sF;	
                        					
                   :}
                   | funcionPrincipal:funP{:
                   		
                   		SeccionFunciones sF = new SeccionFunciones(funP); 
                   		
                   		/*----- Código intermedio -----*/
						
	                    ScopeIF scope = scopeManager.getCurrentScope();
				   		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);   
				   		
				   		cb.addQuadruples(funP.getIntermediateCode());
                   		
                   		sF.setIntermediateCode(cb.create());
                   		RESULT = sF;              
                   :};

funcionPrincipal ::= VACIO principal OPEN_KEY CLOSE_KEY OPEN_PARENTHESIS{:	

                     	//Declarar funcion principal en tabla de tipos y simbolos global                     	
                        ScopeIF globalScope = scopeManager.getCurrentScope();
                     	SymbolTableIF globalTablaSimbolos = globalScope.getSymbolTable();
						TypeTableIF globalTablaTipos = globalScope.getTypeTable();	
                     	
                     	TypeIF tipo = scopeManager.searchType("VACIO");  
						SymbolFunction symbolFunction = new SymbolFunction(globalScope, "principal", tipo);
						globalTablaSimbolos.addSymbol(symbolFunction);	
						TypeFunction typeFunction = new TypeFunction(globalScope, "principal");
						globalTablaTipos.addType("principal", typeFunction);
						
						// Crear ambito de la funcion principal y obtener sus tablas						
						ScopeIF scope = scopeManager.openScope("Funcion principal");							
						SymbolTableIF tablaSimbolos = scope.getSymbolTable();                      
						TypeTableIF tablaTipos = scope.getTypeTable();																								
				  	 :} 
				  	 
				  	 cuerpoFuncion:cFun CLOSE_PARENTHESIS {:		
				  	 	
				  	 	/*----- Análisis semántico -----*/
				  	 	
				  	 	if(cFun.getListadoSentencias().getDevuelve()){
							semanticErrorManager.semanticFatalError("Error: La funcion principal no debe devolver una expresión");
						}	
						
						TypeIF tipo = scopeManager.searchType("VACIO");
						FuncionPrincipal funP = new FuncionPrincipal(tipo,"principal",cFun);
						
						/*----- Código intermedio -----*/
				
						ScopeIF scope = scopeManager.getCurrentScope();
						IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				
						cb.addQuadruples(cFun.getIntermediateCode());
						
						funP.setIntermediateCode(cb.create());
						RESULT = funP;
										
						//cerrar ambito 						
						scopeManager.closeScope();	
		
					 :};

funcion ::= ENTERO IDENTIFICADOR:id OPEN_KEY seccionParametros:sP CLOSE_KEY OPEN_PARENTHESIS
            {:
            	//Declarar funcion en tabla de tipos y tabla de simbolos global             	                  	
                ScopeIF globalScope = scopeManager.getCurrentScope();
                SymbolTableIF globalTablaSimbolos = globalScope.getSymbolTable();
				TypeTableIF globalTablaTipos = globalScope.getTypeTable();	
                     	
                TypeIF type = scopeManager.searchType("ENTERO");  
				SymbolFunction symbolFunction = new SymbolFunction(globalScope, id.getLexema(), type);
				globalTablaSimbolos.addSymbol(symbolFunction);	
				TypeFunction typeFunction = new TypeFunction(globalScope, id.getLexema());
				globalTablaTipos.addType(id.getLexema(), typeFunction);
            	
				// Crear ambito de la funcion y obtener sus tablas								
				ScopeIF scope = scopeManager.openScope("Funcion " + id.getLexema());					
				SymbolTableIF tablaSimbolos = scope.getSymbolTable();                        
				TypeTableIF tablaTipos = scope.getTypeTable();							
				
				//Declaracion de parametros en el ambito de la funcion								
				if(sP != null){							
					symbolFunction.setParametros(sP.getDeclaracionParametros().getListaParam());									
					for(Parametro param : sP.getDeclaracionParametros().getListaParam()){					 
						SymbolParameter symbolParameter = new SymbolParameter(scope, param.getName(), param.getType());							
						tablaSimbolos.addSymbol(symbolParameter);
					}
				}													
			:} 
			 
			cuerpoFuncion:cFun CLOSE_PARENTHESIS {:	
				
				/*----- Análisis semántico -----*/
				
				if(!cFun.getListadoSentencias().getDevuelve()){
					semanticErrorManager.semanticFatalError("Error: La funcion '" +id.getLexema()+"' debe devolver una expresión de tipo entero");
				}
				
				TypeIF tipo = scopeManager.searchType("ENTERO");
				Funcion fun = new Funcion(tipo,id.getLexema(),sP,cFun);
				
				/*----- Código intermedio -----*/
				
				ScopeIF scope = scopeManager.getCurrentScope();
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				
				cb.addQuadruples(cFun.getIntermediateCode());
				
				fun.setIntermediateCode(cb.create());
				RESULT = fun;
				
				//cerrar ambito 				
				scopeManager.closeScope();	
		
			:}
			 
	      | VACIO IDENTIFICADOR:id OPEN_KEY seccionParametros:sP CLOSE_KEY OPEN_PARENTHESIS {:
	      
	        	//Declarar funcion en tabla de tipos y tabla de simbolos global  	        	               	
                ScopeIF globalScope = scopeManager.getCurrentScope();
                SymbolTableIF globalTablaSimbolos = globalScope.getSymbolTable();
				TypeTableIF globalTablaTipos = globalScope.getTypeTable();	
                     	
                TypeIF type = scopeManager.searchType("VACIO");  
				SymbolFunction symbolFunction = new SymbolFunction(globalScope, id.getLexema(), type);
				globalTablaSimbolos.addSymbol(symbolFunction);	
				TypeFunction typeFunction = new TypeFunction(globalScope, id.getLexema());
				globalTablaTipos.addType(id.getLexema(), typeFunction);
				
				// Crea ambito de la funcion y obtener sus tablas									
				ScopeIF scope = scopeManager.openScope("Funcion " + id.getLexema());					
				SymbolTableIF tablaSimbolos = scope.getSymbolTable();                             
				TypeTableIF tablaTipos = scope.getTypeTable();
								
				//Declaracion de parametros en el ambito de la funcion					
				if(sP != null){								
				    symbolFunction.setParametros(sP.getDeclaracionParametros().getListaParam());								
					for(Parametro param : sP.getDeclaracionParametros().getListaParam()){							
						SymbolParameter symbolParameter = new SymbolParameter(scope, param.getName(), param.getType());							
						tablaSimbolos.addSymbol(symbolParameter);
					}				
				}											
			:} 
			 
			cuerpoFuncion:cFun CLOSE_PARENTHESIS {:			
				
				/*----- Análisis semántico -----*/
				
				if(cFun.getListadoSentencias().getDevuelve()){
					semanticErrorManager.semanticFatalError("Error: La funcion '" +id.getLexema()+"' no debe devolver una expresión");
				}
				
				TypeIF tipo = scopeManager.searchType("VACIO");
				Funcion fun = new Funcion(tipo,id.getLexema(),sP,cFun);
				
				/*----- Código intermedio -----*/
				
				ScopeIF scope = scopeManager.getCurrentScope();
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				
				cb.addQuadruples(cFun.getIntermediateCode());
				
				fun.setIntermediateCode(cb.create());
				RESULT = fun;
				
				//cerrar ambito 				
				scopeManager.closeScope();		
		
			:};
			
			
cuerpoFuncion ::= seccionTipos:sT listadoSentencias:lS{:
     
					CuerpoFuncion cP = new CuerpoFuncion(sT,lS);
					
					/*----- Código intermedio -----*/
						   		
					ScopeIF scope = scopeManager.getCurrentScope();
					IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
					
					cb.addQuadruples(lS.getIntermediateCode());
					
					cP.setIntermediateCode(cb.create());
					RESULT = cP;
                :}
                | seccionTipos:sT seccionVariables:sV listadoSentencias:lS{:
					
                	CuerpoFuncion cP = new CuerpoFuncion(sT,sV,lS);
                	
                	/*----- Código intermedio -----*/
						   		
					ScopeIF scope = scopeManager.getCurrentScope();
					IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
					
					cb.addQuadruples(sV.getIntermediateCode());
					cb.addQuadruples(lS.getIntermediateCode());
					
					cP.setIntermediateCode(cb.create());
					RESULT = cP;
                :};
                
seccionParametros ::= declaracionParametros:dP{:		
				
						SeccionParametros sP = new SeccionParametros(dP);	
						
						/*----- Código intermedio -----*/
						   		
						ScopeIF scope = scopeManager.getCurrentScope();
						IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
						
						cb.addQuadruples(dP.getIntermediateCode());
						
						sP.setIntermediateCode(cb.create());
						RESULT = sP;					
			        :} 
			        | epsilon;

declaracionParametros  ::= parametro:param COLON declaracionParametros:dP{:		
								
								dP.add(param);
						   		
						   		/*----- Código intermedio -----*/
						   		
						   		ScopeIF scope = scopeManager.getCurrentScope();
						   		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
						   		
						   		cb.addQuadruples(dP.getIntermediateCode());    
						   		cb.addQuadruples(param.getIntermediateCode()); 
						   		
						   		dP.setIntermediateCode(cb.create());
						   		RESULT = dP;	 	
						 :}
                         | parametro:param {:
                         
                         		DeclaracionParametros dP = new DeclaracionParametros();
                         		dP.add(param);
                         		
                         		/*----- Código intermedio -----*/
						   		
						   		ScopeIF scope = scopeManager.getCurrentScope();
						   		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
						   		
						   		cb.addQuadruples(param.getIntermediateCode()); // anadir el codigo del nuevo parametro
						   		
						   		dP.setIntermediateCode(cb.create());
                         		RESULT = dP;                         
                         :};

parametro ::= ENTERO IDENTIFICADOR:id{:	
		          TypeIF tipo = scopeManager.searchType("ENTERO"); 					
				  RESULT = new Parametro(tipo, id.getLexema());		    	
            :} 
            | IDENTIFICADOR:iden IDENTIFICADOR:id {:            	
            	  if(!scopeManager.containsType(iden.getLexema())){
					  semanticErrorManager.semanticFatalError("Error en linea " + iden.getLine() + ": Tipo de parametro sin declarar");
				  }
            	  TypeIF tipo = scopeManager.searchType(iden.getLexema());					
				  RESULT = new Parametro(tipo, id.getLexema());            
            :};



// EXPRESIONES

expresion ::= NUMERO:num{:
				
				Expresion exp = new Expresion(scopeManager.searchType("ENTERO"));
				ScopeIF scope = scopeManager.getCurrentScope();
				
				/*----- Análisis semántico -----*/
				
				exp.setValue(Integer.parseInt(num.getLexema()));				
				
				/*----- Código intermedio -----*/
				
				TemporalFactory tf = new TemporalFactory(scope);
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				TemporalIF temp = tf.create();
				
				cb.addQuadruple ("MV", temp, Integer.parseInt(num.getLexema()));
				
				exp.setTemporal(temp);
				exp.setIntermediateCode(cb.create());						
				RESULT = exp; 
				
			:}
            | IDENTIFICADOR:id{:
            	
            	Expresion exp = new Expresion(); 
            	ScopeIF scope = scopeManager.getCurrentScope();
            	
            	/*----- Análisis semántico -----*/
            	
                if(!scopeManager.containsSymbol(id.getLexema())){
                	semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": El simbolo '" + id.getLexema() + "' no ha sido declarado");
				}				
				SymbolIF symbol = scopeManager.searchSymbol(id.getLexema());
				exp.setType(symbol.getType()); 
				
				
				/*----- Código intermedio -----*/
				
				TemporalFactory tf = new TemporalFactory(scope);
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				TemporalIF temp = tf.create();
				
				if(symbol instanceof SymbolConstant){
					Value value = new Value(((SymbolConstant)symbol).getValue());
					cb.addQuadruple("MV",temp,value);
					exp.setValue(((SymbolConstant)symbol).getValue()); //para el acceso a vector
				}else if(symbol instanceof SymbolVariable){
					Variable var = new Variable((SymbolVariable)symbol);
					cb.addQuadruple("MVP",temp,var);
					exp.setValue(((SymbolVariable)symbol).getValue()); //para el acceso a vector
				}
				
				exp.setTemporal(temp);
				exp.setIntermediateCode(cb.create());						
				RESULT = exp; 		
									
            :}            
		    | OPEN_KEY expresion:e1 CLOSE_KEY {:  // esta se queda asi segun el pdf
		    	RESULT = e1; 
		    	
		    :}		        
			| expresion:e1 PLUS:op expresion:e2 {:	
				
				Expresion exp = new Expresion(); 
            	ScopeIF scope = scopeManager.getCurrentScope();
            	
				/*----- Análisis semántico -----*/
						 	
			 	if(!(e1.getType() instanceof TypeSimpleEntero) || !(e2.getType() instanceof TypeSimpleEntero)){
					semanticErrorManager.semanticFatalError("Error en linea " + op.getLine() + ": Incompatibilidad de tipos");
				}				
				exp.setType(e1.getType());
				
				/*----- Código intermedio -----*/
				
				TemporalFactory tf = new TemporalFactory(scope);
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				TemporalIF temp1 = e1.getTemporal();
				TemporalIF temp2 = e2.getTemporal();
				TemporalIF temp = tf.create();
				
				cb.addQuadruples (e1.getIntermediateCode());
				cb.addQuadruples (e2.getIntermediateCode());
				cb.addQuadruple ("ADD", temp, temp1, temp2);
				
				exp.setTemporal(temp);
				exp.setIntermediateCode(cb.create());						
				RESULT = exp;
				
			:}						 	
			| expresion:e1 MULT:op expresion:e2 {:		
			
				Expresion exp = new Expresion(); 
            	ScopeIF scope = scopeManager.getCurrentScope();
            	
            	/*----- Análisis semántico -----*/
            		 	
			 	if(!(e1.getType() instanceof TypeSimpleEntero) || !(e2.getType() instanceof TypeSimpleEntero)){
					semanticErrorManager.semanticFatalError("Error en linea " + op.getLine() + ": Incompatibilidad de tipos");
				}				
				exp.setType(e1.getType());
				
				/*----- Código intermedio -----*/
				
				TemporalFactory tf = new TemporalFactory(scope);
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				TemporalIF temp1 = e1.getTemporal();
				TemporalIF temp2 = e2.getTemporal();
				TemporalIF temp = tf.create();
				
				cb.addQuadruples (e1.getIntermediateCode());
				cb.addQuadruples (e2.getIntermediateCode());
				cb.addQuadruple ("MUL", temp, temp1, temp2);
				
				exp.setTemporal(temp);
				exp.setIntermediateCode(cb.create());						
				RESULT = exp;	
							
			:}			
		 	| expresion:e1 AUTO_INCREMENTO:op{:
		 		
		 		Expresion exp = new Expresion(); 
            	ScopeIF scope = scopeManager.getCurrentScope();
            	
            	/*----- Análisis semántico -----*/
						 	
			 	if(!(e1.getType() instanceof TypeSimpleEntero)){
					semanticErrorManager.semanticFatalError("Error en linea " + op.getLine() + ": Incompatibilidad de tipos");
				}				
				exp.setType(e1.getType());
				
		 		/*----- Código intermedio -----*/
				
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				TemporalIF temp = e1.getTemporal();
								
				cb.addQuadruples (e1.getIntermediateCode());
				cb.addQuadruple ("INC", temp);
				
				exp.setTemporal(temp);
				exp.setIntermediateCode(cb.create());						
				RESULT = exp;				
		 		
		 	:}
		 	| NEGACION:op expresion:e1{:
		 	
		 		Expresion exp = new Expresion(); 
            	ScopeIF scope = scopeManager.getCurrentScope();
            	
            	/*----- Análisis semántico -----*/
            	
            	if(!(e1.getType() instanceof TypeSimpleEntero)){
					semanticErrorManager.semanticFatalError("Error en linea " + op.getLine() + ": Incompatibilidad de tipos");
				}
		 		exp.setType(e1.getType());
		 		
		 		/*----- Código intermedio -----*/
		 		
		 		TemporalFactory tf = new TemporalFactory(scope);
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				TemporalIF temp1 = e1.getTemporal();
				TemporalIF temp = tf.create();
				
				cb.addQuadruples (e1.getIntermediateCode ());
				cb.addQuadruple ("NOT", temp, temp1);
				
				exp.setTemporal(temp);
				exp.setIntermediateCode(cb.create());						
				RESULT = exp;
				
		 	:}		 	
		 	| expresion:e1 LOWER_THAN:op expresion:e2{:			
		 		
		 		Expresion exp = new Expresion(); 
            	ScopeIF scope = scopeManager.getCurrentScope();
            	
            	/*----- Análisis semántico -----*/
            	 	
			 	if(!(e1.getType() instanceof TypeSimpleEntero) || !(e2.getType() instanceof TypeSimpleEntero)){
					semanticErrorManager.semanticFatalError("Error en linea " + op.getLine() + ": Incompatibilidad de tipos");
				}
				exp.setType(e1.getType());
				
				/*----- Código intermedio -----*/
				
				TemporalFactory tf = new TemporalFactory(scope);
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				TemporalIF temp1 = e1.getTemporal();
				TemporalIF temp2 = e2.getTemporal();
				TemporalIF temp = tf.create();
				
				cb.addQuadruples (e1.getIntermediateCode());
				cb.addQuadruples (e2.getIntermediateCode());
				cb.addQuadruple ("LS", temp, temp1, temp2);
				
				exp.setTemporal(temp);
				exp.setIntermediateCode(cb.create());						
				RESULT = exp;
						
			:}
		 	| expresion:e1 EQUAL:op expresion:e2{:	
		 		
		 		Expresion exp = new Expresion(); 
            	ScopeIF scope = scopeManager.getCurrentScope();
            	
            	/*----- Análisis semántico -----*/
            		 		
		 		if(!(e1.getType() instanceof TypeSimpleEntero) || !(e2.getType() instanceof TypeSimpleEntero)){
					semanticErrorManager.semanticFatalError("Error en linea " + op.getLine() + ": Incompatibilidad de tipos");
				}
				exp.setType(e1.getType());
				
				
				/*----- Código intermedio -----*/
				
				TemporalFactory tf = new TemporalFactory(scope);
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				TemporalIF temp1 = e1.getTemporal();
				TemporalIF temp2 = e2.getTemporal();
				TemporalIF temp = tf.create();
				
				cb.addQuadruples (e1.getIntermediateCode());
				cb.addQuadruples (e2.getIntermediateCode());
				cb.addQuadruple ("EQ", temp, temp1, temp2);
				
				exp.setTemporal(temp);
				exp.setIntermediateCode(cb.create());						
				RESULT = exp;
						 	
		 	:}
		 	| expresion:e1 AND_LOGICA:op expresion:e2{:		
		 		
		 		Expresion exp = new Expresion(); 
            	ScopeIF scope = scopeManager.getCurrentScope();
            	
            	/*----- Análisis semántico -----*/
            		 	
			 	if(!(e1.getType() instanceof TypeSimpleEntero) || !(e2.getType() instanceof TypeSimpleEntero)){
					semanticErrorManager.semanticFatalError("Error en linea " + op.getLine() + ": Incompatibilidad de tipos");
				}	
				exp.setType(e1.getType());
				
				/*----- Código intermedio -----*/
				
				TemporalFactory tf = new TemporalFactory(scope);
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				TemporalIF temp1 = e1.getTemporal();
				TemporalIF temp2 = e2.getTemporal();
				TemporalIF temp = tf.create();
				
				cb.addQuadruples (e1.getIntermediateCode());
				cb.addQuadruples (e2.getIntermediateCode());
				cb.addQuadruple ("AND", temp, temp1, temp2);
				
				exp.setTemporal(temp);
				exp.setIntermediateCode(cb.create());						
				RESULT = exp;
						
			:}
		 	| accesoVector:aV{:
		 	  	RESULT = aV.getExpresion();
		 	:}
			| llamadaFuncion:fun{:				
			    // Verificar que la llamada a la funcion devuelve un tipo	
				SymbolIF symbolFun = scopeManager.searchSymbol(fun.getName());
				if(!(symbolFun.getType() instanceof TypeSimpleEntero)){
					semanticErrorManager.semanticFatalError("Error: La funcion '" + fun.getName() + "' no devuelve un valor");
				}
				
				Expresion exp = new Expresion(symbolFun.getType());
				exp.setFunction(true);								
				RESULT = exp;	
			:};


accesoVector ::= IDENTIFICADOR:id OPEN_BRACKET expresion:e CLOSE_BRACKET{:
                 	
                 	Expresion exp = new Expresion(e); 
            		ScopeIF scope = scopeManager.getCurrentScope();
            		
                 	/*----- Análisis semántico -----*/
                 	
                 	//comprobar que la variable existe y se trata de un vector
                 	if(!scopeManager.containsSymbol(id.getLexema())){
						semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": No existe " + id.getLexema());							
					}					
                 	SymbolIF symbol = scopeManager.searchSymbol(id.getLexema());
                 	
                 	if(!(symbol.getType() instanceof TypeArray)){
                 		semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": '" + id.getLexema() + "' no es un array");
                 	}
                 	TypeArray typeArray = (TypeArray)symbol.getType(); 
                 	
                 	//comprobar que expresion respeta el rango del vector                   	
                 	if(e.getValue() < 0 || e.getValue() > typeArray.getSize() -1){
                 		semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": acceso a '" + id.getLexema() + "' fuera de límites");
                 	}                	          					
                 	
                 	/*----- Código intermedio -----*/
                 	
                 	TemporalFactory tf = new TemporalFactory(scope);
					IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
					Variable var = new Variable((SymbolVariable)symbol);
                     	
                 	TemporalIF temp = tf.create();
                 	TemporalIF temp1 = tf.create();
                 	TemporalIF temp2 = tf.create();
                 	TemporalIF temp3 = tf.create();
                 	TemporalIF tempPosicion = e.getTemporal();                 	
                 	
                 	cb.addQuadruples(e.getIntermediateCode());
                 	cb.addQuadruple("MVA",temp1,var);         //direccion base de la variable
                 	cb.addQuadruple("MV",temp2,tempPosicion); //desplazamiento
                 	cb.addQuadruple("SUB",temp3,temp1,temp2);
                 	cb.addQuadruple("MVP",temp,temp3);
                 	
                 	exp.setTemporal(temp);
                 	exp.setIntermediateCode(cb.create());
                 	
                 	AccesoVector aV = new AccesoVector(id.getLexema(), exp);
                 	aV.setIntermediateCode(cb.create());
                 	aV.setTemporal(temp);
                 	RESULT = aV;
               :};

llamadaFuncion ::= IDENTIFICADOR:id OPEN_KEY parametros:param CLOSE_KEY{:					
				        
				        //Comprobar si existe la funcion referenciada
				        if(!scopeManager.containsSymbol(id.getLexema())){
				            semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": La función '" + id.getLexema() + "' no ha sido declarada");
					    }
					    
					    // Verificar que se corresponden los parametros actuales y formales
						SymbolFunction sF = (SymbolFunction) scopeManager.searchSymbol(id.getLexema());
						
						if(sF.getParametros().size() != param.getListaExpr().size()){
							semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": Incorrecto número de parámetros en '" + id.getLexema() + "'");
						}	
																
						for(int i = 0; i< sF.getParametros().size(); i++){					
							if(sF.getParametros().get(i).getType() != param.getListaExpr().get(i).getType()){
								semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": Incorrecto tipo/orden de parámetros en '" + id.getLexema() + "'");
							}
						}						
					   
					   RESULT = new LlamadaFuncion(id.getLexema(), param.getListaExpr()); 	
                 :}
	             | IDENTIFICADOR:id OPEN_KEY CLOSE_KEY{:
	             
	             	   if(!scopeManager.containsSymbol(id.getLexema())){
				          semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": La función '" + id.getLexema() + "' no ha sido declarada");
					   }
					   
					   // Verificar que se corresponden los parametros actuales y formales
					   SymbolFunction sF = (SymbolFunction) scopeManager.searchSymbol(id.getLexema());
						
					   if(sF.getParametros().size() > 0){
							semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": Incorrecto número de parámetros en '" + id.getLexema() + "'");
				       }
						
					   RESULT = new LlamadaFuncion(id.getLexema()); 
                 :};
	
	
parametros ::= expresion:e{:

                    Parametros params = new Parametros();
                    params.add(e);
                    
                    /*----- Código intermedio -----*/
                    ScopeIF scope = scopeManager.getCurrentScope();
			   		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
			   		
			   		cb.addQuadruples(e.getIntermediateCode());       
                    
                    params.setIntermediateCode(cb.create());
                    RESULT = params;                         
             :}
             | expresion:e COLON parametros:params{:		
             				   		
			   		params.add(e);
			   		
			   		/*----- Código intermedio -----*/
						   		
			   		ScopeIF scope = scopeManager.getCurrentScope();
			   		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
			   		
			   		cb.addQuadruples(params.getIntermediateCode());  
			   		cb.addQuadruples(e.getIntermediateCode());       
			   		
			   		params.setIntermediateCode(cb.create());			   		
				    RESULT = params;	 	
			 :};


//  SENTENCIAS

bloque ::= OPEN_PARENTHESIS {:

				// Crea ambito del bloque y obtener sus tablas						
				ScopeIF scope = scopeManager.openScope("bloque");
				SymbolTableIF symbolTable = scope.getSymbolTable();   // no lo necesito?
				TypeTableIF typeTable = scope.getTypeTable();		  // no lo necesito?					
			:}
			cuerpoBloque:cBlq CLOSE_PARENTHESIS	{:			
				
				Bloque blq = new Bloque(cBlq);
				
				/*----- Código intermedio -----*/
				
				ScopeIF scope = scopeManager.getCurrentScope();
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				
				cb.addQuadruples(cBlq.getIntermediateCode());				
							
				blq.setIntermediateCode(cb.create());
				RESULT = blq;	
				
				//cerrar ambito 
				scopeManager.closeScope();							
			:};    	 

cuerpoBloque ::= listadoSentencias:lS{:

					CuerpoBloque cuerpoBlq = new CuerpoBloque(lS);
					
					/*----- Código intermedio -----*/
						
	                ScopeIF scope = scopeManager.getCurrentScope();
				   	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				   	
				   	cb.addQuadruples(lS.getIntermediateCode());
				   	
				   	cuerpoBlq.setIntermediateCode(cb.create());						
					RESULT = cuerpoBlq;
					
			   :}
			   | seccionVariables:sV listadoSentencias:lS{:
			   
					CuerpoBloque cuerpoBlq = new CuerpoBloque(lS,sV);
					
					/*----- Código intermedio -----*/
						
	                ScopeIF scope = scopeManager.getCurrentScope();
				   	IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				   	
				   	cb.addQuadruples(sV.getIntermediateCode());
				   	cb.addQuadruples(lS.getIntermediateCode());
					
					cuerpoBlq.setIntermediateCode(cb.create());	
					RESULT = cuerpoBlq;
			   :};

listadoSentencias ::= listadoSentencias:lS sentencia:sent {:
						
						/*----- Análisis semántico -----*/
						
						if(sent instanceof SentenciaDevuelve  &&  ((SentenciaDevuelve)sent).getExpresion() != null){						
							lS.setDevuelve(true);									
						}
						lS.add(sent);			
						
						/*----- Código intermedio -----*/
						
	                    ScopeIF scope = scopeManager.getCurrentScope();
				   		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);				   		
	
				   		cb.addQuadruples(lS.getIntermediateCode()); 
				   		cb.addQuadruples(sent.getIntermediateCode());       
									
						lS.setIntermediateCode(cb.create());	
						RESULT = lS;
					:}
                    | sentencia:sent{:
                    
                    	ListadoSentencias lS = new ListadoSentencias();
                    	
                    	/*----- Análisis semántico -----*/
                    	
                    	if(sent instanceof SentenciaDevuelve && ((SentenciaDevuelve)sent).getExpresion() != null){						
							lS.setDevuelve(true);									
						}												
                    	lS.add(sent);
                    	
                    	/*----- Código intermedio -----*/
						
	                    ScopeIF scope = scopeManager.getCurrentScope();
				   		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				   		
				   		cb.addQuadruples(sent.getIntermediateCode());       
									
						lS.setIntermediateCode(cb.create());					   		
                    	RESULT = lS;
                    :};
                    
			 
sentencia ::= sentenciaDevuelve: sentDevl {: RESULT = sentDevl; :}
  	        | sentenciaIncremento:sentIncrm {: RESULT = sentIncrm; :}
	        | sentenciaAsignacion:sentAsign {: RESULT = sentAsign; :}
	        | sentenciaAsignacionSuma:sentAsignSum {: RESULT = sentAsignSum; :}
	        | sentenciaSi:sentSi {: RESULT = sentSi; :}
	        | sentenciaAlternativas:sentAlt {: RESULT = sentAlt; :}
	        | sentenciaMientras:sentMien {: RESULT = sentMien; :}
	        | sentenciaLlamadaFuncion:sentLlamFun {: RESULT = sentLlamFun; :}
	        | sentenciaSalida:sentSld {: RESULT = sentSld; :}
	        | bloque:blq {: RESULT = blq; :};

sentenciaDevuelve ::= DEVUELVE SEMI_COLON{:						 
						 
						 SentenciaDevuelve sentDvl = new SentenciaDevuelve();
						 
						 /*----- Código intermedio -----*/	
	                	 
	                	 ScopeIF scope = scopeManager.getCurrentScope();
						 TemporalFactoryIF tf = new TemporalFactory(scope);
						 LabelFactory lf = new LabelFactory();
						 IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);	
						 
						 RESULT = sentDvl;			  
					:}
	                | DEVUELVE:d expresion:e SEMI_COLON{:		
	                	  
	                	 SentenciaDevuelve sentDvl = new SentenciaDevuelve(e);
	                	 
	                	 if(!(e.getType() instanceof TypeSimpleEntero)){
							semanticErrorManager.semanticFatalError("Error en linea " + d.getLine() + ": La expresion devuelta debe ser de tipo entero");
						 }
				
	                	 /*----- Código intermedio -----*/	
	                	 
	                	 ScopeIF scope = scopeManager.getCurrentScope();
						 TemporalFactoryIF tf = new TemporalFactory(scope);
						 LabelFactory lf = new LabelFactory();
						 IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
						 
						 TemporalIF temp = e.getTemporal();
	                	 LabelIF l1 = lf.create(scope.getName());
	                	 cb.addQuadruples(e.getIntermediateCode());
	                	 cb.addQuadruple("RETURN",l1,temp);
	                	 
	                	 sentDvl.setIntermediateCode(cb.create());
						 RESULT = sentDvl;					  
					:};

sentenciaIncremento ::= IDENTIFICADOR:id AUTO_INCREMENTO SEMI_COLON{:

							/*----- Análisis semántico -----*/
							
							// comprobar identificador ref existe 
							if(!scopeManager.containsSymbol(id.getLexema())){
								semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": El simbolo '" + id.getLexema() + "' no ha sido declarado");							
							}				
							SymbolIF symbol = scopeManager.searchSymbol(id.getLexema());			
							
							// comprobar que identificadpr es de un tipo que se puede autoincrementar										
							if(symbol instanceof SymbolConstant || symbol instanceof SymbolFunction || symbol.getType() instanceof TypeArray){
								semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": No es posible incrementar '" + id.getLexema() + "'");
							}													
							SentenciaIncremento sentIncrm = new SentenciaIncremento(id.getLexema());
							
							/*----- Código intermedio -----*/
							
							ScopeIF scope = scopeManager.getCurrentScope();
							IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);	
											
							Variable var = new Variable((SymbolVariable)symbol);													
							cb.addQuadruple("INC",var);
							
							sentIncrm.setIntermediateCode(cb.create());
							RESULT = sentIncrm;							
						
					  :};

sentenciaAsignacion ::= ref:r ASSIGN:a expresion:e SEMI_COLON{:							
							
							/*----- Análisis semántico -----*/
							
							// El lado derecho de la asignacion debe ser de tipo entero  
							if(!(e.getType() instanceof TypeSimpleEntero)){
								semanticErrorManager.semanticFatalError("Error en linea " + a.getLine() + ": Asignación de tipos incompatibles");
							}							
							SentenciaAsignacion sentAsign = new SentenciaAsignacion(r,e);
							
							/*----- Código intermedio -----*/
							
							// solo generamos codigo intermedio si la 
							// expresion no es una llamada a funcion		
												
							if(!e.isFunction()){
								ScopeIF scope = scopeManager.getCurrentScope();
								TemporalFactoryIF tf = new TemporalFactory(scope);
								IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);														
							    
								TemporalIF tempExp = e.getTemporal();
								TemporalIF tempRef = r.getTemporal();
								TemporalIF temp = tf.create();										
								
								cb.addQuadruples(e.getIntermediateCode());
								cb.addQuadruples(r.getIntermediateCode());																						
								cb.addQuadruple("STP",tempRef,tempExp);
				
								sentAsign.setIntermediateCode(cb.create());	
							}						
							RESULT = sentAsign;						
													
                      :};
                      
sentenciaAsignacionSuma ::= ref:r ASSIGN_SUMA:as expresion:e SEMI_COLON{:															
								
								/*----- Análisis semántico -----*/
								
								// El lado derecho de la asignacion debe ser de tipo entero  
								if(!(e.getType() instanceof TypeSimpleEntero)){
									semanticErrorManager.semanticFatalError("Error en linea " + as.getLine() + ": Incompatibilidad de tipos");
								}									
								SentenciaAsignacionSuma sentAsignSum = new SentenciaAsignacionSuma(r,e);
								
								/*----- Código intermedio -----*/
								
								// solo generamos codigo intermedio si la 
								// expresion no es una llamada a funcion		
													
								if(!e.isFunction()){
									ScopeIF scope = scopeManager.getCurrentScope();
									TemporalFactoryIF tf = new TemporalFactory(scope);
									IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);									
									SymbolIF symbol = scopeManager.searchSymbol(r.getId());			
								    
									TemporalIF tempExp = e.getTemporal();
									TemporalIF tempRef = r.getTemporal();					
									TemporalIF temp = tf.create();		
									TemporalIF temp2 = tf.create();
									
									cb.addQuadruples(r.getIntermediateCode());
									cb.addQuadruples(e.getIntermediateCode());								
									
									if(symbol instanceof SymbolConstant){
										Value value = new Value(((SymbolConstant)symbol).getValue());
										cb.addQuadruple("MV",temp2,value);									
									}else if(symbol instanceof SymbolVariable){
										Variable var = new Variable((SymbolVariable)symbol);
										cb.addQuadruple("MVP",temp2,var);									
									}								
									cb.addQuadruple ("ADD", temp, temp2, tempExp);												
									cb.addQuadruple("STP",tempRef,temp);                
					
									sentAsignSum.setIntermediateCode(cb.create());	
								}						
								RESULT = sentAsignSum;						
	                      :};


ref ::= IDENTIFICADOR:id {:     

			Ref ref = new Ref(id.getLexema());
						
			/*----- Análisis semántico -----*/
			
			// comprobar si ref existe 
			if(!scopeManager.containsSymbol(id.getLexema())){
				semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": El simbolo '" + id.getLexema() + "' no ha sido declarado");							
			}
			SymbolIF symbol = scopeManager.searchSymbol(id.getLexema());
			
			// comprobar que ref es de un tipo asignable					
			if(symbol instanceof SymbolConstant){
				semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": No es posible modificar una constante");
			}							
			if(symbol instanceof SymbolFunction){
				semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": No es posible asignar a una funcion");
			}
			if(symbol.getType() instanceof TypeArray){
				semanticErrorManager.semanticFatalError("Error en linea " + id.getLine() + ": No es posible hacer asignacion directa a vector");
			}	
			
			/*----- Código intermedio -----*/
			
			ScopeIF scope = scopeManager.getCurrentScope();
			TemporalFactory tf = new TemporalFactory(scope);
			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
			
			TemporalIF temp = tf.create();		
			
			if(symbol instanceof SymbolVariable){	
				Variable var = new Variable((SymbolVariable)symbol);
				cb.addQuadruple ("MVA", temp, var);
			}else if(symbol instanceof SymbolParameter){
				Variable var = new Variable((SymbolParameter)symbol);
				cb.addQuadruple ("MVA", temp, var);
			}
			
			ref.setTemporal(temp);
			ref.setIntermediateCode(cb.create());			
			RESULT = ref;
	  :}
      | accesoVector:aV{:
      		
      		Ref ref = new Ref(aV);
      		
      		/*----- Código intermedio -----*/
			
			ScopeIF scope = scopeManager.getCurrentScope();
			TemporalFactory tf = new TemporalFactory(scope);
			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
			
			cb.addQuadruples(aV.getIntermediateCode());
			ref.setIntermediateCode(cb.create());
			ref.setTemporal(aV.getTemporal());      		
      		RESULT = ref;
      :}; 



sentenciaSi ::= SI:si OPEN_KEY expresion:e CLOSE_KEY sentencia:sSi SINO sentencia:sSino{:   
					
					
					/*----- Análisis semántico -----*/
					
					if(!(e.getType() instanceof TypeSimpleEntero)){
						semanticErrorManager.semanticFatalError("Error en linea " + si.getLine() + ": Expresion no válida");
					}
					SentenciaSi sentSi = new SentenciaSi(e, sSi, sSino);
					
					/*----- Código intermedio -----*/
					
					ScopeIF scope = scopeManager.getCurrentScope();
					IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);					
					LabelFactory lf = new LabelFactory();
					
					LabelIF labelFinSi = lf.create();       	   //etiqueta para fin de las sentencias si
					LabelIF labelSino = lf.create();        	   //etiqueta para el sino
					TemporalIF tempExp = e.getTemporal();
					
					cb.addQuadruples(e.getIntermediateCode());     
					cb.addQuadruple("BRF",tempExp,labelSino);      //si no se cumple la condicion, saltar a etiqueta sino
					cb.addQuadruples(sSi.getIntermediateCode());   //anadir codigo sentencias parte si					
					cb.addQuadruple("BR",labelFinSi);              //salto a etiqueta finSi
					cb.addQuadruple("INL",labelSino);              //etiqueta sino
					cb.addQuadruples(sSino.getIntermediateCode()); //anadir codigo sentencias parte sino
					cb.addQuadruple("INL",labelFinSi);			   //etiqueta fin si
					
					sentSi.setIntermediateCode(cb.create());					
					RESULT = sentSi;			
					
			  :}
	          | SI:si OPEN_KEY expresion:e CLOSE_KEY sentencia:sSi{:
	          		
	          		/*----- Análisis semántico -----*/
					
					if(!(e.getType() instanceof TypeSimpleEntero)){
						semanticErrorManager.semanticFatalError("Error en linea " + si.getLine() + ": Expresion no válida");
					}
					SentenciaSi sentSi = new SentenciaSi(e, sSi, null);
					
					/*----- Código intermedio -----*/
					
					ScopeIF scope = scopeManager.getCurrentScope();
					IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);					
					LabelFactory lf = new LabelFactory();
					
					LabelIF labelFinSi = lf.create();       	   //etiqueta para fin de las sentencias si
					TemporalIF tempExp = e.getTemporal();
					
					cb.addQuadruples(e.getIntermediateCode());     //anadir codigo de la expresion
					cb.addQuadruple("BRF",tempExp,labelFinSi);     //si no se cumple la condicion, saltar a etiqueta finSi
					cb.addQuadruples(sSi.getIntermediateCode());   //anadir codigo sentencias parte si	
					cb.addQuadruple("BR",labelFinSi);              //salto a etiqueta finSi
					cb.addQuadruple("INL",labelFinSi);			   //etiqueta fin si
					
					sentSi.setIntermediateCode(cb.create());					
					RESULT = sentSi;
	          
	          :};
	
sentenciaAlternativas ::= ALTENATIVAS:alt OPEN_KEY expresion:e CLOSE_KEY OPEN_PARENTHESIS casosAlternativa:cA porDefecto:pD CLOSE_PARENTHESIS{:
								
								SentenciaAlternativas sA = new SentenciaAlternativas(e,cA,pD);
								
								/*----- Análisis semántico -----*/
								
								if(!(e.getType() instanceof TypeSimpleEntero)){
									semanticErrorManager.semanticFatalError("Error en linea " + alt.getLine() + ": Expresion no válida");
								}
								
								/*----- Código intermedio -----*/
					
								ScopeIF scope = scopeManager.getCurrentScope();
								IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);	
								TemporalFactory tf = new TemporalFactory(scope);				
								LabelFactory lf = new LabelFactory();								
								
								//LabelIF labelFinSwitch = lf.create();								
								cb.addQuadruples(e.getIntermediateCode()); 										
								TemporalIF tempExp = e.getTemporal();
								TemporalIF tempEQ = tf.create();
								TemporalIF tempAUX = tf.create();
								
								// Compara el numero de cada caso con la expresion. Si hay 
								// coincidencia, genera el codigo intermedio del caso
								for (CasoAlt caso : cA.getCasos()) {				
									
									TemporalIF tempCaso = caso.getTemporal();							        
							        cb.addQuadruples(caso.getIntermediateCode());
							        cb.addQuadruple ("EQ", tempEQ, tempExp, tempCaso);	      // compara temporales de expresion y caso		        
       
							        LabelIF labelFinCaso = lf.create();
							        cb.addQuadruple("BRF",tempEQ,labelFinCaso);               // si no se cumple la condicion, saltar a etiqueta de fin de caso
							        cb.addQuadruples(caso.getBloque().getIntermediateCode()); // generar codigo intermedio para el bloque del caso							        
							        cb.addQuadruple("MV",tempAUX,1);                          						        
							       	cb.addQuadruple("INL",labelFinCaso);			          // etiqueta fin si									        
							    }
							    
							    // Si no hay coincidencia y existe porDefecto, se ejecuta 
							    if (pD != null) {		
							    	LabelIF labelFinDefault = lf.create();        						
        							cb.addQuadruple("HOL",tempAUX,labelFinDefault);	       
							        cb.addQuadruples(pD.getBloque().getIntermediateCode());							        
							        cb.addQuadruple("INL", labelFinDefault);		
							    }						    
							    
							   	sA.setIntermediateCode(cb.create());
								RESULT = sA;
						:};



casosAlternativa ::= casosAlternativa:cA casoAlt:caso{:				
						
						cA.add(caso);
						
						/*----- Código intermedio -----*/
						
						ScopeIF scope = scopeManager.getCurrentScope();
				   		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				   		
				   		cb.addQuadruples(cA.getIntermediateCode());  
				   		cb.addQuadruples(caso.getIntermediateCode());       
						
						cA.setIntermediateCode(cb.create());
						RESULT = cA;
				   :}
                   | casoAlt:caso{:
                   
                   		CasosAlternativa cA = new CasosAlternativa();
                   		cA.add(caso);
                   		
                   		/*----- Código intermedio -----*/
                   		
                   		ScopeIF scope = scopeManager.getCurrentScope();
				   		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
				   		
				   		cb.addQuadruples(caso.getIntermediateCode());
                   		cA.setIntermediateCode(cb.create());
                   		RESULT = cA;
                   :};



casoAlt ::= CASO NUMERO:num TWO_POINTS bloque:blq CORTE SEMI_COLON{:					
				
				int numero = Integer.parseInt(num.getLexema());
				CasoAlt cA = new CasoAlt(numero,blq);
				
				/*----- Código intermedio -----*/					
								
				ScopeIF scope = scopeManager.getCurrentScope();
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
							
				TemporalFactory tf = new TemporalFactory(scope);
				TemporalIF temp = tf.create();
				cb.addQuadruple ("MV", temp, Integer.parseInt(num.getLexema()));
				
				cA.setTemporal(temp);			
				cA.setIntermediateCode(cb.create());
				RESULT = cA;
          :};

porDefecto ::= PORDEFECTO TWO_POINTS bloque:blq CORTE SEMI_COLON{:			   		
			   		
			   		PorDefecto pD = new PorDefecto(blq);
			   		
			   		/*----- Código intermedio -----*/
			   		
			   		ScopeIF scope = scopeManager.getCurrentScope();
					IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
					
					cb.addQuadruples(blq.getIntermediateCode());
					
					pD.setIntermediateCode(cb.create());
			   		RESULT = pD;
			 :}
             | epsilon; 
             
  

sentenciaMientras ::= MIENTRAS:m OPEN_KEY expresion:e CLOSE_KEY sentencia:sent{:	  			
							
							/*----- Análisis semántico -----*/
					
							if(!(e.getType() instanceof TypeSimpleEntero)){
								semanticErrorManager.semanticFatalError("Error en linea " + m.getLine() + ": Expresion no válida");
							}
							SentenciaMientras sentM = new SentenciaMientras(e,sent);
							
							/*----- Código intermedio -----*/
							
							ScopeIF scope = scopeManager.getCurrentScope();
							IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);					
							LabelFactory lf = new LabelFactory();
									
							LabelIF labelIniWhile = lf.create();       	   //etiqueta para inicio del mientras
							LabelIF labelFinWhile = lf.create();           //etiqueta para final del mientras
							TemporalIF tempExp = e.getTemporal();
							
							cb.addQuadruple("INL", labelIniWhile);     	 	//etiqueta comienzo mientras
							cb.addQuadruples(e.getIntermediateCode());  	//anadir codigo de la expresion
							cb.addQuadruple("BRF",tempExp,labelFinWhile);   //si no se cumple la expresion, ir a final del while
							cb.addQuadruples(sent.getIntermediateCode());   //anadir codigo de la sentencia
							cb.addQuadruple("BR",labelIniWhile);            //volver al inicio del while
							cb.addQuadruple("INL",labelFinWhile);           //etiqueta fin while
							
							sentM.setIntermediateCode(cb.create());	
							RESULT = sentM;
                    :};

sentenciaLlamadaFuncion ::= llamadaFuncion:fun SEMI_COLON:sc{:
								
								/*----- Análisis semántico -----*/
								
								// Verificar que la funcion es de tipo vacio	
								SymbolIF symbolFun = scopeManager.searchSymbol(fun.getName());
								if(!(symbolFun.getType() instanceof TypeSimpleVacio)){
									semanticErrorManager.semanticFatalError("Error en linea " + sc.getLine() + ": La funcion debe ser de tipo vacio");
								}									
								SentenciaLlamadaFuncion sentLlamFun = new SentenciaLlamadaFuncion(fun);
								
								/*----- Código intermedio -----*/
								
								ScopeIF scope = scopeManager.getCurrentScope();
								IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
								
								cb.addQuadruples(fun.getIntermediateCode());
									
								sentLlamFun.setIntermediateCode(cb.create());	
								RESULT = sentLlamFun;
                          :};

sentenciaSalida ::= ESCRIBE OPEN_KEY opcionesEscribe:opEsc CLOSE_KEY SEMI_COLON{:
							
							SentenciaSalida sentSld = new SentenciaSalida();
							ScopeIF scope = scopeManager.getCurrentScope();
							
							/*----- Análisis semántico -----*/
								
							if(opEsc != null){
								sentSld.setOpcionEscribe(opEsc.getOpciones());								
							}
							
							/*----- Código intermedio -----*/
							
							TemporalFactory tf = new TemporalFactory(scope);
							IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
							LabelFactory lf = new LabelFactory();							
							
							String str = opEsc.getOpciones();
							LabelIF lb = lf.create();
							TemporalIF temp = tf.create();
							
							cb.addQuadruple("WRITESTR",temp,lb);
														
							// Guardamos la cadena en la lista para recuperarla al final del programa
							listaCadenas.add(new Quadruple("STR",new Label(str),lb));							
														
							sentSld.setIntermediateCode(cb.create());	
							RESULT = sentSld;
						
                  :}
	              | ESCRIBE_ENT OPEN_KEY opcionesEscribeEnt:opEscEnt CLOSE_KEY SEMI_COLON{:
	              			
	              			SentenciaSalida sentSld = new SentenciaSalida();
	              			ScopeIF scope = scopeManager.getCurrentScope();
	              			
	              			/*----- Análisis semántico -----*/
	              			
	              			if(opEscEnt != null){
								sentSld.setOpcionEscribeEntero(opEscEnt.getOpciones());								
							}
							
							/*----- Código intermedio -----*/
							
							
							IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);																					
							TemporalIF temp = opEscEnt.getOpciones().getTemporal();
							
							cb.addQuadruples(opEscEnt.getOpciones().getIntermediateCode());
							cb.addQuadruple("WRITEINT",temp);
							
							sentSld.setIntermediateCode(cb.create());	
							RESULT = sentSld;							
                  :};
	
	
opcionesEscribe ::= epsilon 
                  | STRING:str {:                   
                  		OpcionesEscribe opEsc = new OpcionesEscribe(str.getLexema());
                    	RESULT = opEsc; 
                  :};
                  
opcionesEscribeEnt ::= epsilon 
                     | expresion:e {:                            
                           OpcionesEscribeEnt opEscEnt = new OpcionesEscribeEnt(e); 						   
						   RESULT = opEscEnt;
						   
                     :};
                     
