package compiler.syntax;

// Declaracion de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;

import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

// Declaracion del codigo de usuario

action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

// Declaracion de terminales


terminal Token PLUS;
terminal Token AUTO_INCREMENTO;
terminal Token MULT;
terminal Token AND_LOGICA;
terminal Token OPEN_BRACKET;
terminal Token CLOSE_BRACKET;
terminal Token OPEN_PARENTHESIS;
terminal Token CLOSE_PARENTHESIS;
terminal Token OPEN_KEY;
terminal Token CLOSE_KEY;
terminal Token SEMI_COLON;
terminal Token COLON;
terminal Token TWO_POINTS;
terminal Token NEGACION;
terminal Token EQUAL;
terminal Token ASSIGN_SUMA;
terminal Token ASSIGN;
terminal Token LOWER_THAN;
terminal Token CASO;
terminal Token CONSTANTE;
terminal Token CORTE;
terminal Token ENTERO;
terminal Token ESCRIBE;
terminal Token ESCRIBE_ENT;
terminal Token ALTENATIVAS;
terminal Token MIENTRAS;
terminal Token PORDEFECTO;
terminal Token principal;
terminal Token DEVUELVE;
terminal Token SI;
terminal Token SINO;
terminal Token TIPO;
terminal Token VACIO;
terminal Token IDENTIFICADOR;
terminal Token NUMERO;
terminal Token STRING;


// Declaracion de no terminales

non terminal Program                 program;
non terminal Axiom                   initAxiom;
non terminal Axiom		             axiom;
non terminal FuncionPrincipal        funcionPrincipal;
non terminal Epsilon   			     epsilon;
non terminal SeccionFunciones        seccionFunciones;
non terminal Funcion 			     funcion;
non terminal                	     seccionParametros;
non terminal DeclaracionParametros   declaracionParametros;
non terminal Parametro			     parametro;
non terminal SeccionConstantes	     seccionConstantes;
non terminal DeclaracionConstante    declaracionConstante;
non terminal SeccionTipos		     seccionTipos;
non terminal DeclaracionTipo	     declaracionTipo;
non terminal 			             tamTipo;
non terminal SeccionVariables	     seccionVariables;
non terminal DeclaracionVariable     declaracionVariable;
non terminal ListadoIDs			     listadoIDs;
non terminal Id			             id;
non terminal Expresion               expresion;
non terminal  		     accesoVector;
non terminal LlamadaFuncion		     llamadaFuncion;
non terminal Bloque			         bloque;
non terminal ListadoSentencias       listadoSentencias;
non terminal Sentencia			     sentencia;
non terminal SentenciaIncremento     sentenciaIncremento;
non terminal SentenciaAsignacion     sentenciaAsignacion;
non terminal Ref  			         ref;
non terminal SentenciaAsignacionSuma sentenciaAsignacionSuma;
non terminal SentenciaSi			 sentenciaSi;
non terminal SentenciaAlternativas   sentenciaAlternativas;
non terminal CasosAlternativa		 casosAlternativa;
non terminal CasoAlt			     casoAlt; 
non terminal PorDefecto			     porDefecto;
non terminal SentenciaMientras		 sentenciaMientras;
non terminal SentenciaLlamadaFuncion sentenciaLlamadaFuncion;
non terminal Parametros			     parametros;
non terminal SentenciaSalida         sentenciaSalida;
non terminal OpcionesEscribe         opcionesEscribe;
non terminal OpcionesEscribeEnt		 opcionesEscribeEnt;
non terminal SentenciaDevuelve		 sentenciaDevuelve;

non terminal cuerpoFuncion;
non terminal cuerpoBloque;

// Declaracion de relaciones de precedencia
precedence left 	OPEN_KEY, CLOSE_KEY;
precedence right	OPEN_BRACKET, CLOSE_BRACKET;
precedence left		AUTO_INCREMENTO, NEGACION;
precedence left		MULT;
precedence left		PLUS;
precedence left		LOWER_THAN;
precedence left		EQUAL;
precedence left     AND_LOGICA;
precedence nonassoc SINO;
precedence nonassoc SI;
            

// Declaracion de reglas de produccion


start with program;

program ::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   :}
  initAxiom:ax
  {:   		
  		// No modificar esta estructura, aunque se pueden añadir más acciones semánticas
  		
  		//List intermediateCode = ax.getIntermediateCode ();
  		//finalCodeFactory.create (intermediateCode);

  		// En caso de no comentarse las dos sentencias anteriores se puede generar una excepcion
  		// en las llamadas a cupTest si el compilador no está completo. Esto es debido a que 
  		// aún no se tendrá implementada la generación de código intermedio ni final.
  		// Para la entrega final deberán descomentarse y usarse.
  		
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
  		
   :};

initAxiom ::= {:
				// Creamos ambito global 							
				ScopeIF scope = scopeManager.openScope("global");
												
				// Obtener tablas de tipos e introducir tipos primitivos
				TypeTableIF typeTable = scope.getTypeTable();					
				TypeSimpleEntero tipoEntero = new TypeSimpleEntero(scope, "ENTERO");
				typeTable.addType("ENTERO", tipoEntero);
				TypeSimpleVacio tipoVacio = new TypeSimpleVacio(scope, "VACIO");
				typeTable.addType("VACIO", tipoVacio);							
		  	  :}
			
			  axiom
			
			  {:			
				// Cerrar ambito global
				ScopeIF scope = scopeManager.getCurrentScope();
				scopeManager.closeScope();				
		      :};

axiom ::= seccionConstantes seccionTipos seccionVariables seccionFunciones
        | seccionConstantes seccionTipos seccionFunciones;
 
 
//  CONSTANTES

seccionConstantes ::= declaracionConstante seccionConstantes | epsilon;
epsilon ::= ;

declaracionConstante ::= CONSTANTE IDENTIFICADOR:id NUMERO:value SEMI_COLON{:
							
							// Obtener ambito actual y tablas de simbolos y tipos 
							ScopeIF scope = scopeManager.getCurrentScope();
							SymbolTableIF tablaSimbolos = scope.getSymbolTable();
							TypeTableIF tablaTipos = scope.getTypeTable();
							String name = id.getLexema();
							
							// Comprobar que la constante no este ya declarada
							if(tablaSimbolos.containsSymbol(name)){
								semanticErrorManager.semanticFatalError("Constante " + name + " ya declarada");								
							}else{														
								// Introduce constante en tabla de simbolos	
								TypeIF tipo = scopeManager.searchType("ENTERO");  
								SymbolConstant symbolConstant = new SymbolConstant(scope, name, tipo);
								symbolConstant.setValue(value.getLexema()); 
								tablaSimbolos.addSymbol(symbolConstant);								
							}
					   :};

//  TIPOS 

seccionTipos ::= declaracionTipo seccionTipos | epsilon;

declaracionTipo ::= TIPO ENTERO IDENTIFICADOR:id OPEN_BRACKET tamTipo:tt CLOSE_BRACKET SEMI_COLON {:			      		 		
							
						// Obtener ambito actual y tablas de simbolos y tipos  
						ScopeIF scope = scopeManager.getCurrentScope();
						TypeTableIF tablaTipos = scope.getTypeTable();	
						String name = id.getLexema();
							
						// Comprobar que el tipo no este ya declarado
						if(scopeManager.containsType(name)){
							semanticErrorManager.semanticFatalError("Tipo " + name + " ya declarado");													
						}else{																												
							// Introducir tipo en tabla de tipos								
							TypeArray tipoVector = new TypeArray(scope, name, (int)tt);
							tablaTipos.addType(name, tipoVector);
												
						}
					:}; 

tamTipo ::= NUMERO:num {: 
				RESULT = Integer.parseInt(num.getLexema()); 
		  :}
          | IDENTIFICADOR:id {:
          
                // Buscar la constante en el ambito                 
				SymbolTableIF tablaSimbolos = scopeManager.getCurrentScope().getSymbolTable();
				String name = id.getLexema();
				
				if(!scopeManager.containsSymbol(name)){
					semanticErrorManager.semanticFatalError("No existe la constante");
				}
				
				SymbolConstant c = (SymbolConstant)scopeManager.searchSymbol(name);
				RESULT = Integer.parseInt(c.getValue());					
          :};

//  VARIABLES

seccionVariables ::= seccionVariables declaracionVariable 
	               | declaracionVariable;
		
declaracionVariable ::= ENTERO listadoIDs:listaId SEMI_COLON{:
							
							// Obtener ambito actual y tabla de simbolos
							ScopeIF scope = scopeManager.getCurrentScope();
							SymbolTableIF tablaSimbolos = scope.getSymbolTable();
							
							// Anadir cada identificador a tabla de simbolos							
							for(Id id : listaId.getListaIds()){
								
								String idName = id.getName();
								int idValue = id.getValue();
								
								if(tablaSimbolos.containsSymbol(idName)){
									semanticErrorManager.semanticFatalError("Variable " + idName + " ya declarada");								
								}else{										
									TypeIF tipo = scopeManager.searchType("ENTERO");  
									SymbolVariable symbolVariable = new SymbolVariable(scope, idName, tipo);
									symbolVariable.setValue(idValue); 
									tablaSimbolos.addSymbol(symbolVariable);
								}
							}					
					   :}
					   
 	                  | IDENTIFICADOR:iden listadoIDs:listaId SEMI_COLON{:
							
							// Obtener ambito actual y tabla de simbolos 
							ScopeIF scope = scopeManager.getCurrentScope();
							SymbolTableIF tablaSimbolos = scope.getSymbolTable();				
							
							String type = iden.getLexema();
							
							// Anadir cada identificador a tabla de simbolos
							for(Id id : listaId.getListaIds()){
								
								String idName = id.getName();
																								
								if(tablaSimbolos.containsSymbol(idName)){
									semanticErrorManager.semanticFatalError("Variable " + idName + " ya declarada");								
								}else{									
									if(!scopeManager.containsType(type)){
										semanticErrorManager.semanticFatalError("Tipo no declarado");
									}									
									TypeIF tipo = scopeManager.searchType(type);  
									SymbolVariable symbolVariable = new SymbolVariable(scope, idName, tipo);							
									tablaSimbolos.addSymbol(symbolVariable);
								}
							}					
					   :};

listadoIDs ::= id:id  COLON listadoIDs:listaId {:			   		
			   		listaId.add(id);
			   		RESULT = listaId;
			 :}			 			 
			 | id:id{:			 
			   		ListadoIDs listaId = new ListadoIDs();
			   		listaId.add(id);
			   		RESULT = listaId;			 
			 :} ;

id ::= IDENTIFICADOR:id{:	      		   
            String name = id.getLexema();			
			RESULT = new Id(name, 0);						
     :}     
	 | IDENTIFICADOR:id ASSIGN NUMERO:num{:	   		
   			String name = id.getLexema();
			int value = Integer.parseInt(num.getLexema());			
			RESULT = new Id(name, value);					
     :};

// FUNCIONES

// Se han modificado las producciones de la funcion principal y las funciones para que
// ambas uilicen el no terminal "cuerpoFuncion" y asi evitar conflictos

seccionFunciones ::= funcion seccionFunciones | funcionPrincipal;

funcionPrincipal ::= VACIO principal OPEN_KEY CLOSE_KEY OPEN_PARENTHESIS                      
                     {:	
                     	//Declarar funcion principal en tabla de tipos y simbolos global                     	
                        ScopeIF globalScope = scopeManager.getCurrentScope();
                     	SymbolTableIF globalTablaSimbolos = globalScope.getSymbolTable();
						TypeTableIF globalTablaTipos = globalScope.getTypeTable();	
                     	
                     	TypeIF tipo = scopeManager.searchType("VACIO");  
						SymbolFunction symbolFunction = new SymbolFunction(globalScope, "principal", tipo);
						globalTablaSimbolos.addSymbol(symbolFunction);	
						TypeFunction typeFunction = new TypeFunction(globalScope, "principal");
						globalTablaTipos.addType("principal", typeFunction);
						
						// Crear ambito de la funcion principal y obtener sus tablas						
						ScopeIF scope = scopeManager.openScope("Funcion principal");							
						SymbolTableIF tablaSimbolos = scope.getSymbolTable();  // las necesito?
						TypeTableIF tablaTipos = scope.getTypeTable();		
						
																						
				  	 :} 
				  	 
				  	 cuerpoFuncion CLOSE_PARENTHESIS 
				  	 
				  	 {:			
						//cerrar ambito 
						ScopeIF scope = scopeManager.getCurrentScope();
						scopeManager.closeScope();				
					 :};

funcion ::= ENTERO IDENTIFICADOR:id OPEN_KEY seccionParametros:sP CLOSE_KEY OPEN_PARENTHESIS
            {:
            	//Declarar funcion en tabla de tipos y tabla de simbolos global             	                  	
                ScopeIF globalScope = scopeManager.getCurrentScope();
                SymbolTableIF globalTablaSimbolos = globalScope.getSymbolTable();
				TypeTableIF globalTablaTipos = globalScope.getTypeTable();	
                     	
                TypeIF type = scopeManager.searchType("ENTERO");  
				SymbolFunction symbolFunction = new SymbolFunction(globalScope, id.getLexema(), type);
				globalTablaSimbolos.addSymbol(symbolFunction);	
				TypeFunction typeFunction = new TypeFunction(globalScope, id.getLexema());
				globalTablaTipos.addType(id.getLexema(), typeFunction);
            	
				// Crear ambito de la funcion y obtener sus tablas								
				ScopeIF scope = scopeManager.openScope("Funcion " + id.getLexema());					
				SymbolTableIF tablaSimbolos = scope.getSymbolTable(); // las necesito?
				TypeTableIF tablaTipos = scope.getTypeTable();					
							
				
				//Declaracion de parametros en el ambito de la funcion					
				DeclaracionParametros listaParam = (DeclaracionParametros)sP;
				
				if(listaParam != null){										
					for(Parametro param : listaParam.getListaParam()){							
						String paramName = param.getName();
						String paramType = param.getType();					
																					
						if(!scopeManager.containsType(paramType)){
							semanticErrorManager.semanticFatalError("Tipo del parametro no declarado");
						}
											
						TypeIF tipo = scopeManager.searchType(paramType);  
						SymbolParameter symbolParameter = new SymbolParameter(scope, paramName, tipo);							
						tablaSimbolos.addSymbol(symbolParameter);
					}
				}
													
			:} 
			 
			cuerpoFuncion CLOSE_PARENTHESIS
			
			{:			
				//cerrars ambito 
				ScopeIF scope = scopeManager.getCurrentScope();
				scopeManager.closeScope();				
			:}
			 
	      | VACIO IDENTIFICADOR:id OPEN_KEY seccionParametros:sP CLOSE_KEY OPEN_PARENTHESIS 
	        {:
	        	//Declarar funcion en tabla de tipos y tabla de simbolos global  	        	               	
                ScopeIF globalScope = scopeManager.getCurrentScope();
                SymbolTableIF globalTablaSimbolos = globalScope.getSymbolTable();
				TypeTableIF globalTablaTipos = globalScope.getTypeTable();	
                     	
                TypeIF type = scopeManager.searchType("VACIO");  
				SymbolFunction symbolFunction = new SymbolFunction(globalScope, id.getLexema(), type);
				globalTablaSimbolos.addSymbol(symbolFunction);	
				TypeFunction typeFunction = new TypeFunction(globalScope, id.getLexema());
				globalTablaTipos.addType(id.getLexema(), typeFunction);
				
				// Crea ambito de la funcion y obtener sus tablas									
				ScopeIF scope = scopeManager.openScope("Funcion " + id.getLexema());					
				SymbolTableIF tablaSimbolos = scope.getSymbolTable();   // las necesito?
				TypeTableIF tablaTipos = scope.getTypeTable();
								
				//Declaracion de parametros en el ambito de la funcion	
				DeclaracionParametros listaParam = (DeclaracionParametros)sP;
				
				if(listaParam != null){										
					for(Parametro param : listaParam.getListaParam()){							
						String paramName = param.getName();
						String paramType = param.getType();					
																					
						if(!scopeManager.containsType(paramType)){
							semanticErrorManager.semanticFatalError("Tipo del parametro no declarado");
						}
									
						TypeIF tipo = scopeManager.searchType(paramType);  
						SymbolParameter symbolParameter = new SymbolParameter(scope, paramName, tipo);							
						tablaSimbolos.addSymbol(symbolParameter);
					}				
				}
												
			:} 
			 
			cuerpoFuncion CLOSE_PARENTHESIS
			
			{:			
				//cerrar ambito 
				ScopeIF scope = scopeManager.getCurrentScope();
				scopeManager.closeScope();				
			:};
			

cuerpoFuncion ::= seccionTipos listadoSentencias
                | seccionTipos seccionVariables listadoSentencias;
                
seccionParametros ::= declaracionParametros:listaParam{:						
						RESULT = listaParam;						
			        :} 
			        | epsilon;

declaracionParametros  ::= parametro:param COLON declaracionParametros:listaParam{:						   		
						   		listaParam.add(param);
						   		RESULT = listaParam;	 	
						 :}
                         | parametro:param {:
                         		DeclaracionParametros listaParam = new DeclaracionParametros();
                         		listaParam.add(param);
                         		RESULT = listaParam;                         
                         :};

parametro ::= ENTERO IDENTIFICADOR:id{:
				String name = id.getLexema();						
				RESULT = new Parametro("ENTERO", name);		    	
            :} 
            | IDENTIFICADOR:iden IDENTIFICADOR:id{:
            	String type = iden.getLexema();	
            	String name = id.getLexema();						
				RESULT = new Parametro(type, name);            
            :};



// EXPRESIONES

expresion ::= NUMERO{:RESULT = new Expresion(scopeManager.searchType("ENTERO"));:}
            | IDENTIFICADOR:id{:
                if(!scopeManager.containsSymbol(id.getLexema())){
                	semanticErrorManager.semanticFatalError("El simbolo " + id.getLexema() + " no ha sido declarado");
				}				
				SymbolIF symbol = scopeManager.searchSymbol(id.getLexema());				
				RESULT = new Expresion(symbol.getType()); 							
            :}
            
		    | OPEN_KEY expresion:e1 CLOSE_KEY {::}
		        
			| expresion:e1 PLUS expresion:e2 {:			 	
			 	if(!(e1.getType() instanceof TypeSimpleEntero) || !(e2.getType() instanceof TypeSimpleEntero)){
					semanticErrorManager.semanticFatalError("No se pueden sumar tipos incompatibles");
				}				
				RESULT = new Expresion(e1.getType());
			:}			 	
			| expresion:e1 MULT expresion:e2 {:			 	
			 	if(!(e1.getType() instanceof TypeSimpleEntero) || !(e2.getType() instanceof TypeSimpleEntero)){
					semanticErrorManager.semanticFatalError("No se pueden multiplicar tipos incompatibles");
				}				
				RESULT = new Expresion(e1.getType());
			:}
		 	| expresion:e1 AUTO_INCREMENTO{:
		 		RESULT = new Expresion(e1.getType());
		 	:}
		 	| NEGACION expresion:e1{:
		 		//RESULT = new Expresion(e1.getType());
		 	:}
		 	| expresion:e1 LOWER_THAN expresion:e2{:			 	
			 	if(!(e1.getType() instanceof TypeSimpleEntero) || !(e2.getType() instanceof TypeSimpleEntero)){
					semanticErrorManager.semanticFatalError("No se comparar expresiones de tipos incompatibles");
				}
				RESULT = new Expresion(e1.getType());				
				
			:}
		 	| expresion:e1 EQUAL expresion:e2{:		 		
		 		if(!(e1.getType() instanceof TypeSimpleEntero) || !(e2.getType() instanceof TypeSimpleEntero)){
					semanticErrorManager.semanticFatalError("Tipos incompatibles");
				}
				RESULT = new Expresion(e1.getType());		 	
		 	:}
		 	| expresion:e1 AND_LOGICA expresion:e2{:			 	
			 	if(!(e1.getType() instanceof TypeSimpleEntero) || !(e2.getType() instanceof TypeSimpleEntero)){
					semanticErrorManager.semanticFatalError("No se comparar expresiones de tipos incompatibles");
				}	
				RESULT = new Expresion(e1.getType());			
			:}
		 	| accesoVector
			| llamadaFuncion;

accesoVector ::= IDENTIFICADOR OPEN_BRACKET expresion:e1 CLOSE_BRACKET{:
                 	RESULT = new Expresion(e1.getType());
               :};

llamadaFuncion ::= IDENTIFICADOR OPEN_KEY parametros CLOSE_KEY
	| IDENTIFICADOR OPEN_KEY CLOSE_KEY;
parametros ::= expresion | expresion COLON parametros;

//  SENTENCIAS

bloque ::= OPEN_PARENTHESIS 
		   {:
				// Crea ambito del bloque							
				ScopeIF scope = scopeManager.openScope("bloque");
					
				// Obtenemos la tabla de tipos y la de simbolos 
				SymbolTableIF symbolTable = scope.getSymbolTable();
				TypeTableIF typeTable = scope.getTypeTable();								
			:}
			cuerpoBloque CLOSE_PARENTHESIS
			{:			
				//cerrar ambito 
				ScopeIF scope = scopeManager.getCurrentScope();
				scopeManager.closeScope();				
			:};    	 

cuerpoBloque ::= listadoSentencias
			   | seccionVariables listadoSentencias;

listadoSentencias ::= listadoSentencias sentencia | sentencia;

sentencia ::= sentenciaDevuelve
	| sentenciaIncremento
	| sentenciaAsignacion
	| sentenciaAsignacionSuma
	| sentenciaSi
	| sentenciaAlternativas
	| sentenciaMientras
	| sentenciaLlamadaFuncion
	| sentenciaSalida
	| bloque;

sentenciaDevuelve ::= DEVUELVE SEMI_COLON	
	| DEVUELVE expresion SEMI_COLON;

sentenciaIncremento ::= IDENTIFICADOR AUTO_INCREMENTO SEMI_COLON;

sentenciaAsignacion ::= ref:r ASSIGN expresion:exp SEMI_COLON{:
							
							// comprobar si ref existe en el ambito, si no existe es una asignacion en linea
							// comprobar que ref no es una constante, no se puede asignar valor a una constante
							// comprobar que si ref existe, sea del mismo tipo que expresion 
							// expresion podria incluir una constante
							// expresion podria ser una variable
							
							
						//	if(!scopeManager.containsSymbol()){
							//	semanticErrorManager.semanticFatalError("No existe el simbolo " + );							
							//}
							//SymbolIF symbol = scopeManager.searchSymbol();
                      :};

ref ::= IDENTIFICADOR{:
		
	  :}
      | accesoVector; // devuelve una expresion

sentenciaAsignacionSuma ::= ref ASSIGN_SUMA expresion SEMI_COLON;

sentenciaSi ::= SI OPEN_KEY expresion CLOSE_KEY sentencia SINO sentencia
	 | SI OPEN_KEY expresion CLOSE_KEY sentencia;
	
sentenciaAlternativas ::= ALTENATIVAS OPEN_KEY expresion CLOSE_KEY OPEN_PARENTHESIS casosAlternativa porDefecto CLOSE_PARENTHESIS;
casosAlternativa ::= casosAlternativa casoAlt | casoAlt;

casoAlt ::= CASO NUMERO TWO_POINTS bloque CORTE SEMI_COLON;
porDefecto ::= PORDEFECTO TWO_POINTS bloque CORTE SEMI_COLON | epsilon; 

sentenciaMientras ::= MIENTRAS OPEN_KEY expresion CLOSE_KEY sentencia;

sentenciaLlamadaFuncion ::= llamadaFuncion SEMI_COLON;

sentenciaSalida ::=ESCRIBE OPEN_KEY opcionesEscribe CLOSE_KEY SEMI_COLON
	| ESCRIBE_ENT OPEN_KEY opcionesEscribeEnt CLOSE_KEY SEMI_COLON;
opcionesEscribe ::= epsilon | STRING;
opcionesEscribeEnt ::= epsilon | expresion;
